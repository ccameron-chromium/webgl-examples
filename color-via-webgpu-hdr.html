<html>
<head>
<script>
var current_screen_details;
var rendering_hdr_headroom = 1;

// oklab(60% 0.225 0.126)
//   color(display-p3 0.878 0.144 0.09)
//   color(display-p3 0.878 0.144 0.09) -- no gamut mapping

// oklab(70% 0.225 0.126)
//   color(display-p3 1.02 0.317 0.239)
//   color(display-p3 1 0.317 0.239) -- gamut mapped

// oklab(80% 0.225 0.126)
//   color(display-p3 1.164 0.46 0.366)
//   color(display-p3 1 0.564 0.465)

// oklab(90% 0.225 0.126)
//   color(display-p3 1.31 0.597 0.491)
//   color(display-p3 1 0.774 0.71)

// oklab(99% 0.225 0.126)
//   color(display-p3 1.443 0.719 0.605)
//   color(srgb-linear 2.732 0.399 0.273)

function onCurrentScreenDetailsChanged() {
  let screen_hdr_headroom = current_screen_details.highDynamicRangeHeadroom;
  document.getElementById('DisplayValue').innerText =
      'Screen HDR headroom: ' + screen_hdr_headroom.toFixed(2) + '.';
}

// Clear the canvas to rendering_hdr_headroom using WebGPU.
async function drawWebGPUCanvas(element_id, r, g, b) {
  const canvas = document.getElementById(element_id);
  const adapter = await navigator.gpu?.requestAdapter();
  const device = await adapter?.requestDevice();
  const context = canvas.getContext('webgpu')
  if (!device || !context) {
    console.error("Failed to initialize WebGPU");
    return;
  }
  context.configure({
    device: device,
    format: 'rgba16float',
    colorSpace: 'display-p3',
    usage: GPUTextureUsage.RENDER_ATTACHMENT,
    hdrOptions: {mode:'extended'},
  });

  let v = rendering_hdr_headroom;
  const renderPassDescriptor = {
    colorAttachments: [
      {
        view: context.getCurrentTexture().createView(),
        clearValue: { r:r, g:g, b:b, a: 1.0 },
        loadOp: 'clear',
        storeOp: 'store',
      },
    ],
  };

  const commandEncoder = device.createCommandEncoder();
  const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
  passEncoder.setViewport(0, 0, 32, 32, 0, 1);
  passEncoder.end();
  device.queue.submit([commandEncoder.finish()]);
}

function main() {
  // Configure screen information listener.
  ButtonDetails.addEventListener('click', async function screenDetails() {
    const screens = await window.getScreenDetails();
    current_screen_details = screens.currentScreen;
    onCurrentScreenDetailsChanged();
    screens.addEventListener('currentscreenchange', (event) => {
      current_screen_details = screens.currentScreen;
      onCurrentScreenDetailsChanged();
    });
  })

  drawWebGPUCanvas('WebGPUCanvas_60', 0.878, 0.144, 0.09);
  drawWebGPUCanvas('WebGPUCanvas_70', 1.02, 0.317, 0.239);
  drawWebGPUCanvas('WebGPUCanvas_80', 1.164, 0.46, 0.366);
  drawWebGPUCanvas('WebGPUCanvas_90', 1.31, 0.597, 0.491);
  drawWebGPUCanvas('WebGPUCanvas_99', 1.443, 0.719, 0.605);
}
</script>
</head>

<body onload='main()'>

<p>
This requires that "Experimental Web Platform features" be enabled in chrome://flags.
</p>

<p>The following boxes show the rendering of the sequence of colors:</p>
<ul>
  <li>oklab(60% 0.225 0.126)</li>
  <li>oklab(70% 0.225 0.126)</li>
  <li>oklab(80% 0.225 0.126)</li>
  <li>oklab(90% 0.225 0.126)</li>
  <li>oklab(99% 0.225 0.126)</li>
</ul>
</p>

<p>
<canvas id="WebGPUCanvas_60" style="width:32px; height:32px; margin:0px; padding:0px;"></canvas>
<canvas id="WebGPUCanvas_70" style="width:32px; height:32px; margin:0px; padding:0px;"></canvas>
<canvas id="WebGPUCanvas_80" style="width:32px; height:32px; margin:0px; padding:0px;"></canvas>
<canvas id="WebGPUCanvas_90" style="width:32px; height:32px; margin:0px; padding:0px;"></canvas>
<canvas id="WebGPUCanvas_99" style="width:32px; height:32px; margin:0px; padding:0px;"></canvas>
WebGPU rendering of true color
</p>

<p>
<canvas style="width:32px; height:32px; background-color:oklab(60% 0.255 0.126);"></canvas>
<canvas style="width:32px; height:32px; background-color:oklab(70% 0.255 0.126);"></canvas>
<canvas style="width:32px; height:32px; background-color:oklab(80% 0.255 0.126);"></canvas>
<canvas style="width:32px; height:32px; background-color:oklab(90% 0.255 0.126);"></canvas>
<canvas style="width:32px; height:32px; background-color:oklab(99% 0.255 0.126);"></canvas>
Browser rendering of color
</p>

<p>
<canvas style="width:32px; height:32px; background-color:color(display-p3 0.878 0.144 0.09);"></canvas>
<canvas style="width:32px; height:32px; background-color:color(display-p3 1 0.317 0.239);"></canvas>
<canvas style="width:32px; height:32px; background-color:color(display-p3 1 0.564 0.465);"></canvas>
<canvas style="width:32px; height:32px; background-color:color(display-p3 1 0.774 0.71);"></canvas>
<canvas style="width:32px; height:32px; background-color:color(display-p3 1 0.942 0.923);"></canvas>
CSS gamut mapping of color
</p>

<p>
This is to illustrate the danger of using colors that are far outside of the gamut of the display.
<ul>
<li>If you're on an HDR display, it's likely possible to render the true color, and you'll see it on the top row.</li>
<li>The middle row shows how the color is rendered by your browser.</li>
<li>The last row shows the CSS gamut mapping of the color to the P3 gamut.</li>
</ul>
</p>


<p id="DisplayValue">Screen HDR headroom: (unknown)</p>
<p><button type="button" id="ButtonDetails">Query screen HDR headroom</button></p>

</body>
</html>
