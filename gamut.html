<html>
<head>
</head>
<script>

var texture_color;
var texture_normal;
var renderbuffer_depth;
var fbo;
var fbo_width;
var fbo_height;
var texture_xyzd50_lambda;
var slice_matrix;
var slice_vector;
var flip_slice_vector;
const no_slice_vector = [0, 0, 0, 1.0];

const data_xyzd50_lambda = new Float32Array([
    0.0001299   , 0.00000392  , 0.0006061  , 360 ,
    0.00014585  , 0.00000439  , 0.00068088 , 361 ,
    0.0001638   , 0.00000493  , 0.00076515 , 362 ,
    0.000184    , 0.00000553  , 0.00086001 , 363 ,
    0.00020669  , 0.00000621  , 0.00096659 , 364 ,
    0.0002321   , 0.00000696  , 0.001086   , 365 ,
    0.00026073  , 0.00000781  , 0.00122059 , 366 ,
    0.00029308  , 0.00000877  , 0.00137273 , 367 ,
    0.00032939  , 0.00000984  , 0.00154358 , 368 ,
    0.00036991  , 0.00001104  , 0.00173429 , 369 ,
    0.0004149   , 0.00001239  , 0.001946   , 370 ,
    0.00046416  , 0.00001389  , 0.00217778 , 371 ,
    0.00051899  , 0.00001556  , 0.00243581 , 372 ,
    0.00058185  , 0.00001744  , 0.00273195 , 373 ,
    0.00065523  , 0.00001958  , 0.00307806 , 374 ,
    0.0007416   , 0.00002202  , 0.003486   , 375 ,
    0.00084503  , 0.00002484  , 0.00397523 , 376 ,
    0.00096453  , 0.00002804  , 0.00454088 , 377 ,
    0.00109495  , 0.00003153  , 0.00515832 , 378 ,
    0.00123115  , 0.00003522  , 0.00580291 , 379 ,
    0.001368    , 0.000039    , 0.00645    , 380 ,
    0.00150205  , 0.00004283  , 0.00708322 , 381 ,
    0.00164233  , 0.00004691  , 0.00774549 , 382 ,
    0.00180238  , 0.00005159  , 0.00850115 , 383 ,
    0.00199576  , 0.00005718  , 0.00941454 , 384 ,
    0.002236    , 0.000064    , 0.01054999 , 385 ,
    0.00253539  , 0.00007234  , 0.0119658  , 386 ,
    0.0028926   , 0.00008221  , 0.01365587 , 387 ,
    0.00330083  , 0.00009351  , 0.01558805 , 388 ,
    0.00375324  , 0.00010614  , 0.01773015 , 389 ,
    0.004243    , 0.00012     , 0.02005001 , 390 ,
    0.00476239  , 0.00013498  , 0.02251136 , 391 ,
    0.00533005  , 0.00015149  , 0.02520288 , 392 ,
    0.00597871  , 0.00017021  , 0.02827972 , 393 ,
    0.00674112  , 0.00019182  , 0.03189704 , 394 ,
    0.00765     , 0.000217    , 0.03621    , 395 ,
    0.00875137  , 0.00024691  , 0.04143771 , 396 ,
    0.01002888  , 0.00028124  , 0.04750372 , 397 ,
    0.0114217   , 0.00031852  , 0.05411988 , 398 ,
    0.01286901  , 0.00035727  , 0.06099803 , 399 ,
    0.01431     , 0.000396    , 0.06785001 , 400 ,
    0.01570443  , 0.00043371  , 0.07448632 , 401 ,
    0.01714744  , 0.00047302  , 0.08136156 , 402 ,
    0.01878122  , 0.00051788  , 0.08915364 , 403 ,
    0.02074801  , 0.00057222  , 0.09854048 , 404 ,
    0.02319     , 0.00064     , 0.1102     , 405 ,
    0.02620736  , 0.00072456  , 0.1246133  , 406 ,
    0.02978248  , 0.0008255   , 0.1417017  , 407 ,
    0.03388092  , 0.00094116  , 0.1613035  , 408 ,
    0.03846824  , 0.00106988  , 0.1832568  , 409 ,
    0.04351     , 0.00121     , 0.2074     , 410 ,
    0.0489956   , 0.00136209  , 0.2336921  , 411 ,
    0.0550226   , 0.00153075  , 0.2626114  , 412 ,
    0.0617188   , 0.00172037  , 0.2947746  , 413 ,
    0.069212    , 0.00193532  , 0.3307985  , 414 ,
    0.07763     , 0.00218     , 0.3713     , 415 ,
    0.08695811  , 0.0024548   , 0.4162091  , 416 ,
    0.09717672  , 0.002764    , 0.4654642  , 417 ,
    0.1084063   , 0.0031178   , 0.5196948  , 418 ,
    0.1207672   , 0.0035264   , 0.5795303  , 419 ,
    0.13438     , 0.004       , 0.6456     , 420 ,
    0.1493582   , 0.00454624  , 0.7184838  , 421 ,
    0.1653957   , 0.00515932  , 0.7967133  , 422 ,
    0.1819831   , 0.00582928  , 0.8778459  , 423 ,
    0.198611    , 0.00654616  , 0.959439   , 424 ,
    0.21477     , 0.0073      , 1.0390501  , 425 ,
    0.2301868   , 0.00808651  , 1.1153673  , 426 ,
    0.2448797   , 0.00890872  , 1.1884971  , 427 ,
    0.2587773   , 0.00976768  , 1.2581233  , 428 ,
    0.2718079   , 0.01066443  , 1.3239296  , 429 ,
    0.2839      , 0.0116      , 1.3856     , 430 ,
    0.2949438   , 0.01257317  , 1.4426352  , 431 ,
    0.3048965   , 0.01358272  , 1.4948035  , 432 ,
    0.3137873   , 0.01462968  , 1.5421903  , 433 ,
    0.3216454   , 0.01571509  , 1.5848807  , 434 ,
    0.3285      , 0.01684     , 1.62296    , 435 ,
    0.3343513   , 0.01800736  , 1.6564048  , 436 ,
    0.3392101   , 0.01921448  , 1.6852959  , 437 ,
    0.3431213   , 0.02045392  , 1.7098745  , 438 ,
    0.3461296   , 0.02171824  , 1.7303821  , 439 ,
    0.34828     , 0.023       , 1.74706    , 440 ,
    0.3495999   , 0.02429461  , 1.7600446  , 441 ,
    0.3501474   , 0.02561024  , 1.7696233  , 442 ,
    0.350013    , 0.02695857  , 1.7762637  , 443 ,
    0.349287    , 0.02835125  , 1.7804334  , 444 ,
    0.34806     , 0.0298      , 1.7826     , 445 ,
    0.3463733   , 0.03131083  , 1.7829682  , 446 ,
    0.3442624   , 0.03288368  , 1.7816998  , 447 ,
    0.3418088   , 0.03452112  , 1.7791982  , 448 ,
    0.3390941   , 0.03622571  , 1.7758671  , 449 ,
    0.3362      , 0.038       , 1.77211    , 450 ,
    0.3331977   , 0.03984667  , 1.7682589  , 451 ,
    0.3300411   , 0.041768    , 1.764039   , 452 ,
    0.3266357   , 0.043766    , 1.7589438  , 453 ,
    0.3228868   , 0.04584267  , 1.7524663  , 454 ,
    0.3187      , 0.048       , 1.7441     , 455 ,
    0.3140251   , 0.05024368  , 1.7335595  , 456 ,
    0.308884    , 0.05257304  , 1.7208581  , 457 ,
    0.3032904   , 0.05498056  , 1.7059369  , 458 ,
    0.2972579   , 0.05745872  , 1.6887372  , 459 ,
    0.2908      , 0.06        , 1.6692     , 460 ,
    0.2839701   , 0.06260197  , 1.6475287  , 461 ,
    0.2767214   , 0.06527752  , 1.6234127  , 462 ,
    0.2689178   , 0.06804208  , 1.5960223  , 463 ,
    0.2604227   , 0.07091109  , 1.564528   , 464 ,
    0.2511      , 0.0739      , 1.5281     , 465 ,
    0.2408475   , 0.077016    , 1.4861114  , 466 ,
    0.2298512   , 0.0802664   , 1.4395215  , 467 ,
    0.2184072   , 0.0836668   , 1.3898799  , 468 ,
    0.2068115   , 0.0872328   , 1.3387362  , 469 ,
    0.19536     , 0.09098     , 1.28764    , 470 ,
    0.1842136   , 0.09491755  , 1.2374223  , 471 ,
    0.1733273   , 0.09904584  , 1.1878243  , 472 ,
    0.1626881   , 0.1033674   , 1.1387611  , 473 ,
    0.1522833   , 0.1078846   , 1.090148   , 474 ,
    0.1421      , 0.1126      , 1.0419     , 475 ,
    0.1321786   , 0.117532    , 0.9941976  , 476 ,
    0.1225696   , 0.1226744   , 0.9473473  , 477 ,
    0.1132752   , 0.1279928   , 0.9014531  , 478 ,
    0.1042979   , 0.1334528   , 0.8566193  , 479 ,
    0.09564     , 0.13902     , 0.8129501  , 480 ,
    0.08729955  , 0.1446764   , 0.7705173  , 481 ,
    0.07930804  , 0.1504693   , 0.7294448  , 482 ,
    0.07171776  , 0.1564619   , 0.6899136  , 483 ,
    0.06458099  , 0.1627177   , 0.6521049  , 484 ,
    0.05795001  , 0.1693      , 0.6162     , 485 ,
    0.05186211  , 0.1762431   , 0.5823286  , 486 ,
    0.04628152  , 0.1835581   , 0.5504162  , 487 ,
    0.04115088  , 0.1912735   , 0.5203376  , 488 ,
    0.03641283  , 0.199418    , 0.4919673  , 489 ,
    0.03201     , 0.20802     , 0.46518    , 490 ,
    0.0279172   , 0.2171199   , 0.4399246  , 491 ,
    0.0241444   , 0.2267345   , 0.4161836  , 492 ,
    0.020687    , 0.2368571   , 0.3938822  , 493 ,
    0.0175404   , 0.2474812   , 0.3729459  , 494 ,
    0.0147      , 0.2586      , 0.3533     , 495 ,
    0.01216179  , 0.2701849   , 0.3348578  , 496 ,
    0.00991996  , 0.2822939   , 0.3175521  , 497 ,
    0.00796724  , 0.2950505   , 0.3013375  , 498 ,
    0.00629635  , 0.308578    , 0.2861686  , 499 ,
    0.0049      , 0.323       , 0.272      , 500 ,
    0.00377717  , 0.3384021   , 0.2588171  , 501 ,
    0.00294532  , 0.3546858   , 0.2464838  , 502 ,
    0.00242488  , 0.3716986   , 0.2347718  , 503 ,
    0.00223629  , 0.3892875   , 0.2234533  , 504 ,
    0.0024      , 0.4073      , 0.2123     , 505 ,
    0.00292552  , 0.4256299   , 0.2011692  , 506 ,
    0.00383656  , 0.4443096   , 0.1901196  , 507 ,
    0.00517484  , 0.4633944   , 0.1792254  , 508 ,
    0.00698208  , 0.4829395   , 0.1685608  , 509 ,
    0.0093      , 0.503       , 0.1582     , 510 ,
    0.01214949  , 0.5235693   , 0.1481383  , 511 ,
    0.01553588  , 0.544512    , 0.1383758  , 512 ,
    0.01947752  , 0.56569     , 0.1289942  , 513 ,
    0.02399277  , 0.5869653   , 0.1200751  , 514 ,
    0.0291      , 0.6082      , 0.1117     , 515 ,
    0.03481485  , 0.6293456   , 0.1039048  , 516 ,
    0.04112016  , 0.6503068   , 0.09666748 , 517 ,
    0.04798504  , 0.6708752   , 0.08998272 , 518 ,
    0.05537861  , 0.6908424   , 0.08384531 , 519 ,
    0.06327     , 0.71        , 0.07824999 , 520 ,
    0.07163501  , 0.7281852   , 0.07320899 , 521 ,
    0.08046224  , 0.7454636   , 0.06867816 , 522 ,
    0.08973996  , 0.7619694   , 0.06456784 , 523 ,
    0.09945645  , 0.7778368   , 0.06078835 , 524 ,
    0.1096      , 0.7932      , 0.05725001 , 525 ,
    0.1201674   , 0.8081104   , 0.05390435 , 526 ,
    0.1311145   , 0.8224962   , 0.05074664 , 527 ,
    0.1423679   , 0.8363068   , 0.04775276 , 528 ,
    0.1538542   , 0.8494916   , 0.04489859 , 529 ,
    0.1655      , 0.862       , 0.04216    , 530 ,
    0.1772571   , 0.8738108   , 0.03950728 , 531 ,
    0.18914     , 0.8849624   , 0.03693564 , 532 ,
    0.2011694   , 0.8954936   , 0.03445836 , 533 ,
    0.2133658   , 0.9054432   , 0.03208872 , 534 ,
    0.2257499   , 0.9148501   , 0.02984    , 535 ,
    0.2383209   , 0.9237348   , 0.02771181 , 536 ,
    0.2510668   , 0.9320924   , 0.02569444 , 537 ,
    0.2639922   , 0.9399226   , 0.02378716 , 538 ,
    0.2771017   , 0.9472252   , 0.02198925 , 539 ,
    0.2904      , 0.954       , 0.0203     , 540 ,
    0.3038912   , 0.9602561   , 0.01871805 , 541 ,
    0.3175726   , 0.9660074   , 0.01724036 , 542 ,
    0.3314384   , 0.9712606   , 0.01586364 , 543 ,
    0.3454828   , 0.9760225   , 0.01458461 , 544 ,
    0.3597      , 0.9803      , 0.0134     , 545 ,
    0.3740839   , 0.9840924   , 0.01230723 , 546 ,
    0.3886396   , 0.9874182   , 0.01130188 , 547 ,
    0.4033784   , 0.9903128   , 0.01037792 , 548 ,
    0.4183115   , 0.9928116   , 0.00952931 , 549 ,
    0.4334499   , 0.9949501   , 0.00875    , 550 ,
    0.4487953   , 0.9967108   , 0.0080352  , 551 ,
    0.464336    , 0.9980983   , 0.0073816  , 552 ,
    0.480064    , 0.999112    , 0.0067854  , 553 ,
    0.4959713   , 0.9997482   , 0.0062428  , 554 ,
    0.5120501   , 1.          , 0.00575    , 555 ,
    0.5282959   , 0.9998567   , 0.0053036  , 556 ,
    0.5446916   , 0.9993046   , 0.0048998  , 557 ,
    0.5612094   , 0.9983255   , 0.0045342  , 558 ,
    0.5778215   , 0.9968987   , 0.0042024  , 559 ,
    0.5945      , 0.995       , 0.0039     , 560 ,
    0.6112209   , 0.9926005   , 0.0036232  , 561 ,
    0.6279758   , 0.9897426   , 0.0033706  , 562 ,
    0.6447602   , 0.9864444   , 0.0031414  , 563 ,
    0.6615697   , 0.9827241   , 0.0029348  , 564 ,
    0.6784      , 0.9786      , 0.00275    , 565 ,
    0.6952392   , 0.9740837   , 0.0025852  , 566 ,
    0.7120586   , 0.9691712   , 0.0024386  , 567 ,
    0.7288284   , 0.9638568   , 0.0023094  , 568 ,
    0.7455188   , 0.9581349   , 0.0021968  , 569 ,
    0.7621      , 0.952       , 0.0021     , 570 ,
    0.7785432   , 0.9454504   , 0.00201773 , 571 ,
    0.7948256   , 0.9384992   , 0.0019482  , 572 ,
    0.8109264   , 0.9311628   , 0.0018898  , 573 ,
    0.8268248   , 0.9234576   , 0.00184093 , 574 ,
    0.8425      , 0.9154      , 0.0018     , 575 ,
    0.8579325   , 0.9070064   , 0.00176627 , 576 ,
    0.8730816   , 0.8982772   , 0.0017378  , 577 ,
    0.8878944   , 0.8892048   , 0.0017112  , 578 ,
    0.9023181   , 0.8797816   , 0.00168307 , 579 ,
    0.9163      , 0.87        , 0.00165    , 580 ,
    0.9297995   , 0.8598613   , 0.00161013 , 581 ,
    0.9427984   , 0.849392    , 0.0015644  , 582 ,
    0.9552776   , 0.838622    , 0.0015136  , 583 ,
    0.9672179   , 0.8275813   , 0.00145853 , 584 ,
    0.9786      , 0.8163      , 0.0014     , 585 ,
    0.9893856   , 0.8047947   , 0.00133667 , 586 ,
    0.9995488   , 0.793082    , 0.00127    , 587 ,
    1.0090892   , 0.781192    , 0.001205   , 588 ,
    1.0180064   , 0.7691547   , 0.00114667 , 589 ,
    1.0263      , 0.757       , 0.0011     , 590 ,
    1.0339827   , 0.7447541   , 0.0010688  , 591 ,
    1.040986    , 0.7324224   , 0.0010494  , 592 ,
    1.047188    , 0.7200036   , 0.0010356  , 593 ,
    1.0524667   , 0.7074965   , 0.0010212  , 594 ,
    1.0567      , 0.6949      , 0.001      , 595 ,
    1.0597944   , 0.6822192   , 0.00096864 , 596 ,
    1.0617992   , 0.6694716   , 0.00092992 , 597 ,
    1.0628068   , 0.6566744   , 0.00088688 , 598 ,
    1.0629096   , 0.6438448   , 0.00084256 , 599 ,
    1.0622      , 0.631       , 0.0008     , 600 ,
    1.0607352   , 0.6181555   , 0.00076096 , 601 ,
    1.0584436   , 0.6053144   , 0.00072368 , 602 ,
    1.0552244   , 0.5924756   , 0.00068592 , 603 ,
    1.0509768   , 0.5796379   , 0.00064544 , 604 ,
    1.0456      , 0.5668      , 0.0006     , 605 ,
    1.0390369   , 0.5539611   , 0.00054787 , 606 ,
    1.0313608   , 0.5411372   , 0.0004916  , 607 ,
    1.0226662   , 0.5283528   , 0.0004354  , 608 ,
    1.0130477   , 0.5156323   , 0.00038347 , 609 ,
    1.0026      , 0.503       , 0.00034    , 610 ,
    0.9913675   , 0.4904688   , 0.00030725 , 611 ,
    0.9793314   , 0.4780304   , 0.00028316 , 612 ,
    0.9664916   , 0.4656776   , 0.00026544 , 613 ,
    0.9528479   , 0.4534032   , 0.00025181 , 614 ,
    0.9384      , 0.4412      , 0.00024    , 615 ,
    0.923194    , 0.42908     , 0.00022955 , 616 ,
    0.907244    , 0.417036    , 0.00022064 , 617 ,
    0.890502    , 0.405032    , 0.00021196 , 618 ,
    0.87292     , 0.393032    , 0.00020219 , 619 ,
    0.8544499   , 0.381       , 0.00019    , 620 ,
    0.835084    , 0.3689184   , 0.00017421 , 621 ,
    0.814946    , 0.3568272   , 0.00015564 , 622 ,
    0.794186    , 0.3447768   , 0.00013596 , 623 ,
    0.772954    , 0.3328176   , 0.00011685 , 624 ,
    0.7514      , 0.321       , 0.0001     , 625 ,
    0.7295836   , 0.3093381   , 0.00008613 , 626 ,
    0.7075888   , 0.2978504   , 0.0000746  , 627 ,
    0.6856022   , 0.2865936   , 0.000065   , 628 ,
    0.6638104   , 0.2756245   , 0.00005693 , 629 ,
    0.6424      , 0.265       , 0.00005    , 630 ,
    0.6215149   , 0.2547632   , 0.00004416 , 631 ,
    0.6011138   , 0.2448896   , 0.00003948 , 632 ,
    0.5811052   , 0.2353344   , 0.00003572 , 633 ,
    0.5613977   , 0.2260528   , 0.00003264 , 634 ,
    0.5419      , 0.217       , 0.00003    , 635 ,
    0.5225995   , 0.2081616   , 0.00002765 , 636 ,
    0.5035464   , 0.1995488   , 0.00002556 , 637 ,
    0.4847436   , 0.1911552   , 0.00002364 , 638 ,
    0.4661939   , 0.1829744   , 0.00002181 , 639 ,
    0.4479      , 0.175       , 0.00002    , 640 ,
    0.4298613   , 0.1672235   , 0.00001813 , 641 ,
    0.412098    , 0.1596464   , 0.0000162  , 642 ,
    0.394644    , 0.1522776   , 0.0000142  , 643 ,
    0.3775333   , 0.1451259   , 0.00001213 , 644 ,
    0.3608      , 0.1382      , 0.00001    , 645 ,
    0.3444563   , 0.1315003   , 0.00000773 , 646 ,
    0.3285168   , 0.1250248   , 0.0000054  , 647 ,
    0.3130192   , 0.1187792   , 0.0000032  , 648 ,
    0.2980011   , 0.1127691   , 0.00000133 , 649 ,
    0.2835      , 0.107       ,-0.         , 650 ,
    0.2695448   , 0.1014762   ,-0.         , 651 ,
    0.2561184   , 0.09618864  ,-0.         , 652 ,
    0.2431896   , 0.09112296  , 0.         , 653 ,
    0.2307272   , 0.08626485  ,-0.         , 654 ,
    0.2187      , 0.0816      ,-0.         , 655 ,
    0.2070971   , 0.07712064  , 0.         , 656 ,
    0.1959232   , 0.07282552  , 0.         , 657 ,
    0.1851708   , 0.06871008  , 0.         , 658 ,
    0.1748323   , 0.06476976  , 0.         , 659 ,
    0.1649      , 0.061       , 0.         , 660 ,
    0.1553667   , 0.05739621  , 0.         , 661 ,
    0.14623     , 0.05395504  , 0.         , 662 ,
    0.13749     , 0.05067376  , 0.         , 663 ,
    0.1291467   , 0.04754965  , 0.         , 664 ,
    0.1212      , 0.04458     , 0.         , 665 ,
    0.1136397   , 0.04175872  , 0.         , 666 ,
    0.106465    , 0.03908496  , 0.         , 667 ,
    0.09969044  , 0.03656384  , 0.         , 668 ,
    0.09333061  , 0.03420048  , 0.         , 669 ,
    0.0874      , 0.032       , 0.         , 670 ,
    0.08190096  , 0.02996261  , 0.         , 671 ,
    0.07680428  , 0.02807664  , 0.         , 672 ,
    0.07207712  , 0.02632936  , 0.         , 673 ,
    0.06768664  , 0.02470805  , 0.         , 674 ,
    0.0636      , 0.0232      , 0.         , 675 ,
    0.05980685  , 0.02180077  , 0.         , 676 ,
    0.05628216  , 0.02050112  , 0.         , 677 ,
    0.05297104  , 0.01928108  , 0.         , 678 ,
    0.04981861  , 0.01812069  , 0.         , 679 ,
    0.04677     , 0.017       , 0.         , 680 ,
    0.04378405  , 0.01590379  , 0.         , 681 ,
    0.04087536  , 0.01483718  , 0.         , 682 ,
    0.03807264  , 0.01381068  , 0.         , 683 ,
    0.03540461  , 0.01283478  , 0.         , 684 ,
    0.0329      , 0.01192     , 0.         , 685 ,
    0.03056419  , 0.01106831  , 0.         , 686 ,
    0.02838056  , 0.01027339  , 0.         , 687 ,
    0.02634484  , 0.00953331  , 0.         , 688 ,
    0.02445275  , 0.00884616  , 0.         , 689 ,
    0.0227      , 0.00821     , 0.         , 690 ,
    0.02108429  , 0.00762378  , 0.         , 691 ,
    0.01959988  , 0.00708542  , 0.         , 692 ,
    0.01823732  , 0.00659148  , 0.         , 693 ,
    0.01698717  , 0.00613849  , 0.         , 694 ,
    0.01584     , 0.005723    , 0.         , 695 ,
    0.01479064  , 0.00534306  , 0.         , 696 ,
    0.01383132  , 0.0049958   , 0.         , 697 ,
    0.01294868  , 0.0046764   , 0.         , 698 ,
    0.0121292   , 0.00438008  , 0.         , 699 ,
    0.01135916  , 0.004102    , 0.         , 700 ,
    0.01062935  , 0.00383845  , 0.         , 701 ,
    0.00993885  , 0.0035891   , 0.         , 702 ,
    0.00928842  , 0.00335422  , 0.         , 703 ,
    0.00867885  , 0.00313409  , 0.         , 704 ,
    0.00811092  , 0.002929    , 0.         , 705 ,
    0.00758239  , 0.00273814  , 0.         , 706 ,
    0.00708875  , 0.00255988  , 0.         , 707 ,
    0.00662731  , 0.00239324  , 0.         , 708 ,
    0.00619541  , 0.00223727  , 0.         , 709 ,
    0.00579035  , 0.002091    , 0.         , 710 ,
    0.00540983  , 0.00195359  , 0.         , 711 ,
    0.00505258  , 0.00182458  , 0.         , 712 ,
    0.00471751  , 0.00170358  , 0.         , 713 ,
    0.00440351  , 0.00159019  , 0.         , 714 ,
    0.00410946  , 0.001484    , 0.         , 715 ,
    0.00383391  , 0.0013845   , 0.         , 716 ,
    0.00357575  , 0.00129127  , 0.         , 717 ,
    0.00333434  , 0.00120409  , 0.         , 718 ,
    0.00310908  , 0.00112274  , 0.         , 719 ,
    0.00289933  , 0.001047    , 0.         , 720 ,
    0.00270435  , 0.00097659  , 0.         , 721 ,
    0.00252302  , 0.00091111  , 0.         , 722 ,
    0.00235417  , 0.00085013  , 0.         , 723 ,
    0.00219662  , 0.00079324  , 0.         , 724 ,
    0.00204919  , 0.00074     , 0.         , 725 ,
    0.00191096  , 0.00069008  , 0.         , 726 ,
    0.00178144  , 0.00064331  , 0.         , 727 ,
    0.00166011  , 0.0005995   , 0.         , 728 ,
    0.00154646  , 0.00055845  , 0.         , 729 ,
    0.00143997  , 0.00052     , 0.         , 730 ,
    0.00134004  , 0.00048391  , 0.         , 731 ,
    0.00124627  , 0.00045005  , 0.         , 732 ,
    0.00115847  , 0.00041835  , 0.         , 733 ,
    0.00107643  , 0.00038872  , 0.         , 734 ,
    0.00099995  , 0.0003611   , 0.         , 735 ,
    0.00092874  , 0.00033538  , 0.         , 736 ,
    0.00086243  , 0.00031144  , 0.         , 737 ,
    0.00080075  , 0.00028917  , 0.         , 738 ,
    0.0007434   , 0.00026845  , 0.         , 739 ,
    0.00069008  , 0.0002492   , 0.         , 740 ,
    0.00064052  , 0.0002313   , 0.         , 741 ,
    0.0005945   , 0.00021469  , 0.         , 742 ,
    0.00055186  , 0.00019929  , 0.         , 743 ,
    0.00051243  , 0.00018505  , 0.         , 744 ,
    0.00047602  , 0.0001719   , 0.         , 745 ,
    0.00044245  , 0.00015978  , 0.         , 746 ,
    0.00041151  , 0.0001486   , 0.         , 747 ,
    0.00038298  , 0.0001383   , 0.         , 748 ,
    0.00035665  , 0.00012879  , 0.         , 749 ,
    0.0003323   , 0.00012     , 0.         , 750 ,
    0.00030976  , 0.00011186  , 0.         , 751 ,
    0.00028889  , 0.00010432  , 0.         , 752 ,
    0.00026954  , 0.00009734  , 0.         , 753 ,
    0.00025157  , 0.00009085  , 0.         , 754 ,
    0.00023483  , 0.0000848   , 0.         , 755 ,
    0.00021917  , 0.00007915  , 0.         , 756 ,
    0.00020453  , 0.00007386  , 0.         , 757 ,
    0.00019084  , 0.00006892  , 0.         , 758 ,
    0.00017807  , 0.0000643   , 0.         , 759 ,
    0.00016615  , 0.00006     , 0.         , 760 ,
    0.00015502  , 0.00005598  , 0.         , 761 ,
    0.00014462  , 0.00005223  , 0.         , 762 ,
    0.00013491  , 0.00004872  , 0.         , 763 ,
    0.00012585  , 0.00004545  , 0.         , 764 ,
    0.00011741  , 0.0000424   , 0.         , 765 ,
    0.00010955  , 0.00003956  , 0.         , 766 ,
    0.00010222  , 0.00003692  , 0.         , 767 ,
    0.00009539  , 0.00003445  , 0.         , 768 ,
    0.00008902  , 0.00003215  , 0.         , 769 ,
    0.00008308  , 0.00003     , 0.         , 770 ,
    0.00007751  , 0.00002799  , 0.         , 771 ,
    0.00007231  , 0.00002611  , 0.         , 772 ,
    0.00006746  , 0.00002436  , 0.         , 773 ,
    0.00006293  , 0.00002272  , 0.         , 774 ,
    0.00005871  , 0.0000212   , 0.         , 775 ,
    0.00005477  , 0.00001978  , 0.         , 776 ,
    0.0000511   , 0.00001845  , 0.         , 777 ,
    0.00004768  , 0.00001722  , 0.         , 778 ,
    0.00004449  , 0.00001606  , 0.         , 779 ,
    0.00004151  , 0.00001499  , 0.         , 780,
    0.0001299   , 0.00000392  , 0.0006061  , 360 ,
    ]);

var canvas;
var gl;
var program;

var dragging_shift = false;
var dragging = false;
var dragging_last_x;
var dragging_last_y;

var plane_vertices;
var plane_indices;
var plane_indices_count;

var plane_wire_indices = [0, 0];
var plane_wire_indices_count = [0, 0];

var view_fov = 5;
var view_z = 4;
var view_rotation_x = 13;
var view_rotation_y = -54;

let compileShader = function(gl, vertex_source, fragment_source) {
  let vertex_shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertex_shader, vertex_source);
  gl.compileShader(vertex_shader);
  if (!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(vertex_shader));
     
  let fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragment_shader, fragment_source); 
  gl.compileShader(fragment_shader);
  if (!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(fragment_shader));
  
  let program = gl.createProgram();
  gl.attachShader(program, vertex_shader);
  gl.attachShader(program, fragment_shader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    throw new Error(gl.getProgramInfoLog(program));

  return program;
}

const gamut_common = `
  const int kXYZ = 0;
  const int kRec2020YUV = 7;
  const int kSRGB = 1;
  const int kSRGBLinear = 2;
  const int kP3Linear = 6;
  const int kRec2020Linear = 3;
  const int kOkLab = 4;
  const int kWavelength = 5;

  uniform sampler2D texture_xyzd50_lambda;
  uniform highp int input_position_type;
  uniform float input_hdr_headroom;
  uniform highp int output_position_type;
  uniform float tonemap_hdr_headroom;

  mat3 p3_to_xyzd50 = mat3( 0.515102,  0.241182,  -0.00104941,
                            0.291965,  0.692236,   0.0418818,
                            0.157153,  0.0665819,  0.784378);
  mat3 srgb_to_xyzd50 = mat3( 0.43606567, 0.2224884,  0.01391602,
                              0.38514709, 0.71687317, 0.09707642,
                              0.14306641, 0.06060791, 0.71409607);
  mat3 rec2020_to_xyzd50 = mat3( 0.673459,  0.279033,   -0.00193139,
                                 0.165661,  0.675338,    0.0299794,
                                 0.1251,    0.0456288,   0.797162);
  mat3 xyzd50_to_rec2020 = mat3( 1.6472752,  -0.68261762,  0.02966273,
                                -0.39360248,  1.64761778, -0.06291669,
                                -0.23598029,  0.01281627,  1.25339643);
  mat3 xyzd50_to_p3 = mat3( 2.40404516, -0.84222838,  0.04818706,
                           -0.98989869,  1.79885051, -0.09737385,
                           -0.39763172,  0.01604817,  1.27350664);
  mat3 xyzd50_to_srgb = mat3( 3.13411215, -0.97878729,  0.07198304,
                             -1.61739246,  1.91627959, -0.22898585,
                             -0.4906334,   0.03345471,  1.40538513);
  mat3 xyzd50_to_xyzd65 = mat3( 0.95547345, -0.02836971,  0.01231400,
                               -0.02309854,  1.00999546, -0.02050770,
                                0.06325931,  0.02104140,  1.33036594);
  mat3 xyzd65_to_xyzd50 = mat3( 1.04792976,  0.02962780, -0.00924303,
                                0.02294695,  0.99043437,  0.01505523,
                               -0.05019232, -0.01707377,  0.75187428);
  mat3 xyzd65_to_lms = mat3( 0.81902244, 0.03298367, 0.04817720,
                             0.36190626, 0.92928685, 0.26423952,
                            -0.12887378, 0.03614467, 0.63354783);
  mat3 lms_to_xyzd65 = mat3( 1.22687987, -0.04057576, -0.07637295,
                            -0.55781500,  1.11228683, -0.42149332,
                             0.28139105, -0.07171107,  1.58692402);
  mat3 lms_to_oklab = mat3( 0.21045426, 1.97799850, 0.02590404,
     0.79361779, -2.42859221, 0.78277177,
     -0.00407205, 0.45059371, -0.80867577);
  mat3 oklab_to_lms = mat3( 1.00000000, 1.00000001, 1.00000005,
     0.39633779, -0.10556134, -0.08948418,
     0.21580376, -0.06385417, -1.29148554);

  // Y_rec2020 is the luminance vector in rec2020 primaries.
  vec3 rec2020_rgb_to_yuv(vec3 rgb) {
    mat4 rgb_to_yuv = mat4(
        0.262700, -0.139630,  0.500000,  0.0,
        0.678000, -0.360370, -0.459786,  0.0,
        0.059300,  0.500000, -0.040214,  0.0,
        0.000000,  0.500122,  0.500122,  1.0);
    return (rgb_to_yuv * vec4(rgb, 1.0)).rgb;
  }
  vec3 rec2020_yuv_to_rgb(vec3 yuv) {
    mat4 yuv_to_rgb =  mat4(
         1.0,         1.0,         1.0,         0.0,
        -0.00000089, -0.16455278,  1.88139998,  0.0,
         1.47459975, -0.57135301, -0.00000024,  0.0,
        -0.73747933,  0.36804268, -0.9409294,   1.0);
    return (yuv_to_rgb * vec4(yuv, 1.0)).rgb;
  }

  vec3 xyzd50_to_oklab(vec3 xyzd50) {
    vec3 lms = xyzd65_to_lms * xyzd50_to_xyzd65 * xyzd50;
    vec3 Lab = lms_to_oklab * (sign(lms) * pow(abs(lms), vec3(1.0/3.0)));
    return Lab + vec3(0.0, 0.5, 0.5);
  }

  vec3 oklab_to_xyzd50(vec3 Lab) {
    vec3 x = oklab_to_lms * (Lab - vec3(0.0, 0.5, 0.5));
    vec3 lms = sign(x) * pow(abs(x), vec3(3.0));
    return xyzd65_to_xyzd50 * lms_to_xyzd65 * lms;
  }

  vec3 lambda_to_xyzd50(vec3 c) {
    float lambda = c.x;
    vec3 xyz = texture(texture_xyzd50_lambda, vec2(lambda, 0.0)).rgb;
    return c.y * xyz;
  }

  float parametricEval(float x, float a, float b, float c, float d, float e, float f, float g) {
    float abs_x = abs(x);
    float sgn_x = sign(x);
    if (abs_x < d) {
      return c * x + f;
    }
    return sgn_x * (pow(a * abs_x + b, g) + e);
  }
  float srgbToLinear(float x) {
    const float a = 0.947867345704;
    const float b = 0.052132654296;
    const float c = 0.077399380805;
    const float d = 0.040449937172;
    const float g = 2.4;
    return parametricEval(x, a, b, c, d, 0.0, 0.0, g);
  }
  float linearToSrgb(float x) {
    const float a = 1.1371188301409823;
    const float c = 12.919999999992248;
    const float d = 0.003130800090713953;
    const float e = -0.05499994754780801;
    const float g = 0.4166666666666667;
    return parametricEval(x, a, 0.0, c, d, e, 0.0, g);
  }
  vec3 srgbToLinear(vec3 c) {
    return vec3(srgbToLinear(c.r), srgbToLinear(c.g), srgbToLinear(c.b));
  }
  vec3 linearToSrgb(vec3 c) {
    return vec3(linearToSrgb(c.r), linearToSrgb(c.g), linearToSrgb(c.b));
  }

  float toneMapGain(float Y, float Lc, float Ld) {
    if (Lc <= Ld) {
      return 1.0;
    }
    float a = Ld / (Lc*Lc);
    float b = 1.0 / Ld;
    return (1.0 + a*Y) / (1.0 + b*Y);
  }
  float toneMapInvGain(float Ytm, float Lc, float Ld) {
    if (Lc <= Ld) {
      return 1.0;
    }
    if (Ytm == 0.0) {
      return 1.0;
    }
    float a = Ld / (Lc*Lc);
    float b = 1.0 / Ld;
    return (sqrt(4.0*a*Ytm + pow(b*Ytm-1.0, 2.0)) + b*Ytm-1.0) / (2.0*a*Ytm);
  }

  vec3 convert(vec3 c, int from, float from_hdr_headroom, int to, float to_hdr_headroom) {
    if (from == to && from_hdr_headroom == to_hdr_headroom) {
      return c;
    }

    // Convert YUV to RGB.
    if (from == kRec2020YUV) {
      c = rec2020_yuv_to_rgb(c);
    }

    // Convert nonlinear to linear.
    if (from == kSRGB || from == kRec2020YUV) {
      c  = srgbToLinear(c);
    }

    // Convert primaries to XYZD50
    if (from == kSRGB || from == kSRGBLinear) {
      c = srgb_to_xyzd50 * c;
    }
    else if (from == kP3Linear) {
      c = p3_to_xyzd50 * c;
    }
    else if (from == kRec2020Linear || from == kRec2020YUV) {
      c = rec2020_to_xyzd50 * c;
    }

    // Direct-to-XYZD50 conversions.
    if (from == kWavelength) {
      c = lambda_to_xyzd50(c);
    }
    else if (from == kOkLab) {
      c = oklab_to_xyzd50(c);
    }

    // c is now xyzd50

    // Apply HDR headroom (and tonemapping) here.
    {
      vec3 kRec2020Y = vec3(0.262700, 0.678000, 0.059300);    
      c *= from_hdr_headroom;
      if (from_hdr_headroom > tonemap_hdr_headroom) {
        c *= toneMapGain(dot(kRec2020Y, xyzd50_to_rec2020*c), from_hdr_headroom, tonemap_hdr_headroom);
      }
      if (to_hdr_headroom > tonemap_hdr_headroom) {
        c *= toneMapInvGain(dot(kRec2020Y, xyzd50_to_rec2020*c), to_hdr_headroom, tonemap_hdr_headroom);
      }
      c /= to_hdr_headroom;
    }

    // Direct-from-XYZD50 conversions.
    if (to == kOkLab) {
      c = xyzd50_to_oklab(c);
    }

    // Convert primaries from XYZD50
    {
      if (to == kSRGB || to == kSRGBLinear) {
        c = xyzd50_to_srgb * c;
      }
      else if (to == kP3Linear) {
        c = xyzd50_to_p3 * c;
      }
      else if (to == kRec2020Linear || to == kRec2020YUV) {
        c = xyzd50_to_rec2020 * c;
      }
    }

    // Convert linear to nonlinear.
    if (to == kSRGB || to == kRec2020YUV) {
      c  = linearToSrgb(c);
    }

    // Convert RGB to YUV.
    if (to == kRec2020YUV) {
      c = rec2020_rgb_to_yuv(c);
    }

    return c;
  }

  vec3 convert(vec3 c, int from, int to) {
    return convert (c, from, 1.0, to, 1.0);
  }

  bool inGamut(vec3 c, int from, int to, float headroom) {
    vec3 converted = convert(c, from, 1.0, to, headroom);
    return converted == clamp(converted, 0.0, 1.0);
  }

  vec3 intersectWithUnitCube(vec3 a, vec3 b) {
    float alpha = 1.0;
    for (int i = 0; i < 3; ++i) {
      if (a[i] > 1.0) {
        float alpha_i = (1.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      } else if (a[i] < 0.0) {
        float alpha_i = (0.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      }
    }
    alpha = max(alpha, 0.0);
    return alpha * a + (1.0 - alpha) * b;
  }

  vec3 gamutMapScale(vec3 rgb) {
    return intersectWithUnitCube(rgb, vec3(0.0, 0.0, 0.0));
  }

  vec3 gamutMapScaleUV(vec3 rgb) {
    float Y = rec2020_rgb_to_yuv(rgb).r;
    return intersectWithUnitCube(rgb, vec3(Y, Y, Y));
  }

  bool inGamut(vec3 c, int from, int to) {
    return inGamut(c, from, to, 1.0);
  }

    `;

const blit_vs = `
    attribute vec2 position;
    varying vec2 v_texcoord;

    void main() {
      v_texcoord.xy = (0.5 * position.xy) + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
    `;

const blit_fs = `
    precision highp float;
    uniform sampler2D texture_color;
    uniform sampler2D texture_normal;
    uniform vec2 viewport;
    varying vec2 v_texcoord;

    float edgeDetect() {
      float dx = 1.0 / viewport.x;
      float dy = 1.0 / viewport.y;

      vec3 n = 2.0 * (texture2D(texture_normal, v_texcoord).rgb - vec3(0.5, 0.5, 0.5));
      for (int i = 0; i < 2; ++i) {
        for (int j = 0; j < 2; ++j) {
          float x = v_texcoord.x + float(i - 1) * dx;
          float y = v_texcoord.y + float(j - 1) * dy;
          vec3 n_ij = 2.0 * (texture2D(texture_normal, vec2(x,y)).rgb - vec3(0.5, 0.5, 0.5));
          if (max(length(n), length(n_ij)) < 0.5) {
            continue;
          }
          float cos_theta = dot(n, n_ij);
          if (cos_theta < 0.9) {
            return 1.0;
          }
        }
      }
      return 0.0;
    }

    void main() {
      vec4 color = texture2D(texture_color, v_texcoord.xy);

      color.rgb *= 1.0 - vec3(edgeDetect());

      gl_FragColor.rgb = color.rgb;
      gl_FragColor.a = 1.0;
    }
    `;

const black_vs = `
    uniform mat4 matrixProjection;
    uniform mat4 matrixModelView;
    uniform mat4 matrixSubModel;
    attribute vec4 position;

    void main() {
      gl_Position = matrixProjection * matrixModelView * matrixSubModel * position;
    }
    `;

const black_fs = `
    precision highp float;
    uniform vec4 color;

    void main() {
      gl_FragColor = color;
    }
    `;

const kXYZ = 0;
const kRec2020YUV = 7;
const kSRGB = 1;
const kSRGBLinear = 2;
const kP3Linear = 6;
const kRec2020Linear = 3;
const kOkLab = 4;
const kWavelength = 5;

const gamut_vs = `#version 300 es
    precision highp float;
    uniform mat4 matrixProjection;
    uniform mat4 matrixModelView;
    uniform mat4 matrixSubModel;
    in vec4 position;
    in vec4 color;
    out vec3 v_xyzd50;
    out vec3 v_position;
    out vec3 v_normal;
    ` + gamut_common + `
    void main() {
      vec3 in_color = (matrixSubModel * position).xyz;
      v_xyzd50 = convert(in_color, input_position_type, input_hdr_headroom, kXYZ, 1.0);
      v_position = convert(v_xyzd50, kXYZ, output_position_type);

      // Use finite difference for normals because work is hard.
      vec4 epsilon = vec4(0.0, 0.0, 0.05, 0.0);
      vec3 in_color_fd_normal = (matrixSubModel * (position + epsilon)).xyz;
      vec3 out_color_fd_normal = convert(in_color_fd_normal, input_position_type, input_hdr_headroom, output_position_type, 1.0);

      v_normal = normalize(out_color_fd_normal - v_position);

      gl_Position = matrixProjection * matrixModelView * vec4(v_position, 1.0);
    }`;

const gamut_fs = `#version 300 es
    precision highp float;
    uniform vec4 color;
    uniform vec4 slice_vector;
    uniform highp int gamut_map_space;
    uniform highp int gamut_map_discard;
    uniform highp int gamut_map_type;
    uniform float gamut_map_headroom;
    in vec3 v_xyzd50;
    in vec3 v_position;
    in vec3 v_normal;
    layout(location = 0) out vec4 f_out_color;
    layout(location = 1) out vec4 f_out_normal;
    ` + gamut_common + `
    void main() {
      vec3 srgb_color = convert(v_xyzd50, kXYZ, kSRGB);
      vec3 srgb_color_clamped = clamp(srgb_color, 0.0, 1.0);

      // Discard based on slicing.
      if (dot(slice_vector, vec4(v_position, 1.0)) < 0.0) {
        discard;
      }
      // Discard out-of-gamut.
      if (gamut_map_discard == 1) {
        if (!inGamut(v_xyzd50, kXYZ, gamut_map_space, gamut_map_headroom)) {
          discard;
        }
      }

      // Gamut map
      if (gamut_map_type != 0) {
        // CSS
        if (gamut_map_type == 1) {
          vec3 c = convert(v_xyzd50, kXYZ, kRec2020Linear);
          c = clamp(c, 0.0, 1.0);
          srgb_color = convert(c, kRec2020Linear, kSRGB);
        }
        if (gamut_map_type == 2) {
          if (!inGamut(v_xyzd50, kXYZ, gamut_map_space)) {
            vec3 Lab = convert(v_xyzd50, kXYZ, kOkLab);
            vec3 Loo = vec3(min(Lab.x, 1.0), 0.5, 0.5);
            float alpha0 = 0.0;
            float alpha1 = 1.0;
            for (int i = 0; i < 8; ++i) {
              float alpha_test = 0.5 * (alpha0 + alpha1);
              vec3 Lab_test = alpha_test * Lab + (1.0 - alpha_test) * Loo;
              if (inGamut(Lab_test, kOkLab, gamut_map_space)) {
                alpha0 = alpha_test;
              } else {
                alpha1 = alpha_test;
              }
            }
            float alpha_final = 0.5 * (alpha0 + alpha1);
            vec3 Lab_final = alpha_final * Lab + (1.0 - alpha_final) * Loo;
            srgb_color = convert(Lab_final, kOkLab, kSRGB);
          }
        }
        // L2
        if (gamut_map_type == 3) {
          vec3 c = convert(v_xyzd50, kXYZ, kRec2020Linear);
          float M = max(max(c.r, c.g), c.b);
          if (M > 1.0) {
            vec3 u = vec3(1.0, 1.0, 1.0);
            vec3 v = u - (1.0/M) * c;
            vec3 w = (1.0 - 1.0/M) * c;
            float alpha = dot(v, w) / dot(v, v);
            c = ((1.0 - alpha)/M) * c + (alpha)*u;
            c = clamp(c, 0.0, 1.0);
          }
          srgb_color = convert(c, kRec2020Linear, kSRGB);
        }
        // Y
        if (gamut_map_type == 4) {
          vec3 c = convert(v_xyzd50, kXYZ, kRec2020Linear);
          c = gamutMapScaleUV(c);
          srgb_color = convert(c, kRec2020Linear, kSRGB);
        }
      }

      f_out_color.rgb = clamp(color.rgb * srgb_color, 0.0, 16.0);
      f_out_color.a = 1.0;

      f_out_normal.rgb = 0.5 * normalize(v_normal) + vec3(0.5);
      f_out_normal.a = 1.0;


    }`;

let matrixOrtho2D = function(left, right, bottom, top, znear, zfar) {
    var tx = -(right+left)/(right-left);
    var ty = -(top+bottom)/(top-bottom);
    var tz = -(zfar+znear)/(zfar-znear);
    return [2/(right-left), 0,               0,              tx,
            0,              2/(top-bottom),  0,              ty,
            0,              0,              -2/(zfar-znear), tz,
            0,              0,               0,              1];
}

let matrixPerspective = function(fovy, aspect, znear, zfar) {
    var ymax = znear * Math.tan(fovy * Math.PI / 360.0);
    var ymin = -ymax;
    var xmin = ymin * aspect;
    var xmax = ymax * aspect;
    return matrixFrustum(xmin, xmax, ymin, ymax, znear, zfar);
}

let matrixFrustum = function(left, right, bottom, top, znear, zfar) {
    var X = 2*znear/(right-left);
    var Y = 2*znear/(top-bottom);
    var A = (right+left)/(right-left);
    var B = (top+bottom)/(top-bottom);
    var C = -(zfar+znear)/(zfar-znear);
    var D = -2*zfar*znear/(zfar-znear);
    return [X, 0,  A, 0,
            0, Y,  B, 0,
            0, 0,  C, D,
            0, 0, -1, 0];
}

let matrixRotation = function(axis, angleInDegrees) {
  const angleInRadians = angleInDegrees * Math.PI / 180;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  if (axis == 'x') {
    return [ 1,  0, 0, 0,
             0,  c, s, 0,
             0, -s, c, 0,
             0,  0, 0, 1];
  }
  if (axis == 'y') {
    return [ c, 0, -s, 0,
             0, 1,  0, 0,
             s, 0,  c, 0,
             0, 0,  0, 1];
  }
  if (axis == 'z') {
    return [ c, s, 0, 0,
            -s, c, 0, 0,
             0, 0, 1, 0,
             0, 0, 0, 1];
  }
}

let matrixTranslation = function(tx, ty, tz) {
  return [ 1,  0,  0, 0,
           0,  1,  0, 0,
           0,  0,  1, 0,
          tx, ty, tz, 1];
}

let matrixScale= function(sx, sy, sz) {
  return [sx,  0,  0, 0,
           0, sy,  0, 0,
           0,  0, sz, 0,
           0,  0,  0, 1];
}

let matrixIdentity = function() {
  return [1, 0, 0, 0,
          0, 1, 0, 0,
          0, 0, 1, 0,
          0, 0, 0, 1];
}

let matrixMultiply = function(a, b) {
  let c = [0,0,0,0,
           0,0,0,0,
           0,0,0,0,
           0,0,0,0];
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      for (let k = 0; k < 4; ++k) {
        c[4*i + j] += a[4*k + j] * b[4*i + k];
      }
    }
  }
  return c;
}

let vecScale = function(a, x) {
  return [a*x[0], a*x[1], a*x[2]];
}

let vecAdd = function(a, b) {
  return [a[0]+b[0], a[1]+b[1], a[2]+b[2]];
}

let vecSub = function(a, b) {
  return [a[0]-b[0], a[1]-b[1], a[2]-b[2]];
}

let vecCross = function(a, b) {
  return [
      a[1]*b[2] - a[2]*b[1],
      a[2]*b[0] - a[0]*b[2],
      a[0]*b[1] - a[1]*b[0]];
}

let vecDot = function(a, b) {
  return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
}

let vecProject = function(a, b) {
  return vecScale(vecDot(a, b) / vecDot(b, b), b);
}

let vecAbs = function(a) {
  return [Math.abs(a[0]), Math.abs(a[1]), Math.abs(a[2])];
}

let vecNormInfty = function(a) {
  a = vecAbs(a);
  return Math.max(Math.max(a[0], a[1]), a[2]);
}

let matrixPlaneToPlane = function(a, b, c) {
  let M = [0,0,0,0,
           0,0,0,0,
           0,0,0,0,
           0,0,0,1];
  let ab = vecSub(b, a);
  let ac = vecSub(c, a);
  let ad = vecProject(ac, ab);
  let dc = vecSub(ac, ad);
  let z = vecCross(ab, ac);

  for (let i = 0; i < 3; ++i) {
    M[4*0 + i] = ab[i];
    M[4*1 + i] = dc[i];
    M[4*2 + i] = z[i];
    M[4*3 + i] = a[i];
  }
  return M;
}

let sliceVector = function(a, b, c) {
  let n = vecCross(vecSub(b, a), vecSub(c, a));
  return [-n[0], -n[1], -n[2], vecDot(n, a)];
}

let matrixApply = function(A, x, normalize) {
  let b = [0,0,0,0];
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      b[i] += A[4*j + i] * x[j];
    }
  }
  if (normalize) {
    for (let i = 0; i < 4; ++i) {
      b[i] /= b[3];
    }
  }
  return b;
}

let matrixDump = function(A) {
  str = '';
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      str += (A[4*i + j] * 1.0).toFixed(2) + ', ';
    }
    str += '\n';
  }
  console.log(str);
}

let matrixConcat = function(a) {
  let c = matrixIdentity();
  for (let i = 0; i < a.length; ++i) {
    c = matrixMultiply(c, a[i]);
  }
  return c;
}

const kGrid1x1   = 0;
const kGrid4x4   = 1;
const kGrid16x16 = 2;
const kGrid32x32 = 3;
const kGrid32x8 = 4;

let makePlane = function() {
  // n = 17
  // 6 * (17x17 + 16x16)
  const n = 129;
  let nGrids = 5;
  let steps = [
    [(n-1) /  1, (n-1) /  1], // kGrid1x1
    [(n-1) /  4, (n-1) /  4], // kGrid4x4
    [(n-1) / 16, (n-1) / 16], // kGrid16x16
    [(n-1) / 32, (n-1) / 32], // kGrid32x32
    [(n-1) / 32, (n-1) /  8], // kGrid32x8
    ];

  {
    let data = new Float32Array(4 * (n*n + (n-1)*(n-1)));
    for (let x = 0; x < n; ++x) {
      for (let y = 0; y < n; ++y) {
        let offset = 4 * (y*n + x);
        data[offset+0] = x/(n-1);
        data[offset+1] = y/(n-1);
        data[offset+2] = 0.0;
        data[offset+3] = 1.0;
      }
    }
    for (let x = 0; x < n-1; ++x) {
      for (let y = 0; y < n-1; ++y) {
        let offset = 4 * (n*n + y*(n-1) + x);
        data[offset+0] = (x + 0.5)/(n-1);
        data[offset+1] = (y + 0.5)/(n-1);
        data[offset+2] = 0.0;
        data[offset+3] = 1.0;
      }
    }
    plane_vertices = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, plane_vertices);
    gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  }

  {
    let nTriangles = 4 * (n - 1) * (n - 1);
    let indices = new Uint16Array(3 * nTriangles);
    let i = 0;
    for (let x = 0; x < n-1; ++x) {
      for (let y = 0; y < n-1; ++y) {
        let i0 = (y+0)*n + (x+0);
        let i1 = (y+0)*n + (x+1);
        let i2 = (y+1)*n + (x+1);
        let i3 = (y+1)*n + (x+0);
        let ic = n*n + y*(n-1) + x;
        indices[i++] = i0; indices[i++] = ic; indices[i++] = i1;
        indices[i++] = i1; indices[i++] = ic; indices[i++] = i2;
        indices[i++] = i2; indices[i++] = ic; indices[i++] = i3;
        indices[i++] = i3; indices[i++] = ic; indices[i++] = i0;
      }
    }
    plane_indices = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, plane_indices);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    plane_indices_count = indices.length;
  }

  for (let grid_index = 0; grid_index < nGrids; ++grid_index) {
    let nLines = 2 * n * n;
    let indices = new Uint16Array(2 * nLines);
    let i = 0;
    let step_x = steps[grid_index][0];
    let step_y = steps[grid_index][1];
    for (let x = 0; x < n-1; x += 1) {
      for (let y = 0; y < n; y += step_y) {
        indices[i++] = (y+0)*n + (x+0);
        indices[i++] = (y+0)*n + (x+1);
      }
    }
    for (let x = 0; x < n; x += step_x) {
      for (let y = 0; y < n-1; y += 1) {
        indices[i++] = (y+0)*n + (x+0);
        indices[i++] = (y+1)*n + (x+0);
      }
    }

    plane_wire_indices[grid_index] = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, plane_wire_indices[grid_index]);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
    plane_wire_indices_count[grid_index] = i;
  }

}

let updateSlice = function() {
  var a, b, c;
  let h = 1.0;
  if (GamutRender_Solid.checked || RadioPlane_HDR.checked) {
    h = ContentHdrHeadroom.value;
  }
  if (SliceAxis.value == 0) {
    a = [SliceValue.value, 1-h, 1-h];
    b = [SliceValue.value,   h, 1-h];
    c = [SliceValue.value, 1-h,  h];
  }
  if (SliceAxis.value == 1) {
    a = [0, SliceValue.value, 1-h];
    b = [h, SliceValue.value, 1-h];
    c = [0, SliceValue.value,   h];
  }
  if (SliceAxis.value == 2) {
    a = [1-h, 1-h, SliceValue.value];
    b = [  h, 1-h, SliceValue.value];
    c = [1-h,   h, SliceValue.value];
  }
  if (SliceAxis.value == 3) {
    c = Math.cos(Math.pi * SliceValue.value);
    s = Math.sin(Math.pi * SliceValue.value);
    a = [0, 1.0, 1];
    b = [1, 1.0, 1];
    c = [0, 0.0, 0];

//

    a = [0, 1.0, 1];
    b = [1, 1.0, 1];
    c = [0, 0.0, 0];

  }

  slice_matrix = matrixPlaneToPlane(a, b, c);
  if (SliceFlip.checked) {
    slice_vector = sliceVector(a, c, b);
  } else {
    slice_vector = sliceVector(a, b, c);
  }
  flip_slice_vector = [
      -slice_vector[0], -slice_vector[1], -slice_vector[2], -slice_vector[3]];
}

let drawGrid = function(program, gridIndex) {
  gl.bindBuffer(gl.ARRAY_BUFFER, plane_vertices);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, plane_wire_indices[gridIndex]);

  let positionLocation = gl.getAttribLocation(program, 'position');
  gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  gl.drawElements(gl.LINES, plane_wire_indices_count[gridIndex], gl.UNSIGNED_SHORT, 0);
}

let drawPlane = function(program) {
  gl.bindBuffer(gl.ARRAY_BUFFER, plane_vertices);
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, plane_indices);

  let positionLocation = gl.getAttribLocation(program, 'position');
  gl.vertexAttribPointer(positionLocation, 4, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  gl.drawElements(gl.TRIANGLES, plane_indices_count, gl.UNSIGNED_SHORT, 0);
}

let drawCube = function(program, grid_index = null, scale = 1.0) {
  const axes = ['x', 'x', 'x', 'x', 'y', 'y'];
  const angles = [0, 90, 180, 270, 90, 270];
  for (let i = 0; i < 6; ++i) {
    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'matrixSubModel'), false,
        matrixConcat([
            matrixScale(scale, scale, scale),
            matrixTranslation(0.5, 0.5, 0.5),
            matrixRotation(axes[i], angles[i]),
            matrixTranslation(-0.5, -0.5, -0.5),
            ]));
    if (grid_index != null) {
      drawGrid(program, grid_index);
    } else {
      drawPlane(program);
    }
  }

  gl.uniformMatrix4fv(gl.getUniformLocation(program, 'matrixSubModel'), false,
      matrixIdentity());
}

let moveElementToPoint = function(element, matrix, point) {
  const a0xyzw = matrixApply(matrix, point, true);
  let a0x = canvas.clientWidth  * (a0xyzw[0] + 1) / 2 - 8;
  let a0y = canvas.clientHeight * (1 - a0xyzw[1]) / 2 - 32;
  let r = canvas.getBoundingClientRect();
  
  element.style.left = (r.left + a0x) + 'px';
  element.style.top  = (r.top + window.scrollY + a0y) + 'px';
}

let drawToFbo = function(width, height) {
  gl.viewport(0, 0, width, height);

  gl.drawBuffers([gl.COLOR_ATTACHMENT0, gl.COLOR_ATTACHMENT1]);

  gl.clearBufferfv(gl.COLOR, 0, [1.0, 1.0, 1.0, 1.0]);
  gl.clearBufferfv(gl.COLOR, 1, [0.5, 0.5, 0.5, 0.0]);

  gl.clear(gl.DEPTH_BUFFER_BIT);
  gl.enable(gl.DEPTH_TEST);

  let matrixProjection = null;
  let matrixModelView = null;
  {
    matrixProjection = matrixPerspective(view_fov, width / height, 2, 6);
    // matrixProjection = matrixOrtho2D(-width / height, width / height, -1.0, 1.0, -2.0, 2.0);
  }
  {
    let matrices = []
    matrices.push(matrixTranslation(0, -0.2 * Math.max(view_z - 4), -view_z));
    matrices.push(matrixRotation('x', view_rotation_x));
    matrices.push(matrixRotation('y', view_rotation_y));

    if (RadioGeo_OkLab.checked || RadioGeo_Rec2020YUV.checked) {
    } else {
      matrices.push(matrixRotation('x', 55));
      matrices.push(matrixRotation('y', -135));
    }

    matrices.push([ 0, 1, 0, 0,
                     -1,  0, 0, 0,
                      0,  0, 1, 0,
                      0,  0, 0, 1]);
    matrices.push(matrixTranslation(-0.5, -0.5, -0.5));
    matrixModelView = matrixConcat(matrices);
  }

  const matrixModelViewProjection = matrixConcat([matrixProjection, matrixModelView]);
  moveElementToPoint(AxisOrigin,  matrixModelViewProjection, [0, 0, 0, 1]);
  moveElementToPoint(Axis0,     matrixModelViewProjection, [1, 0, 0, 1]);
  moveElementToPoint(Axis1,     matrixModelViewProjection, [0, 1, 0, 1]);
  moveElementToPoint(Axis2,     matrixModelViewProjection, [0, 0, 1, 1]);

  let out_space = kOkLab;
  if (RadioGeo_sRGB.checked) {
    Axis0.innerText = 'R'; Axis1.innerText = 'G'; Axis2.innerText = 'B';
    out_space = kSRGBLinear;
  }
  if (RadioGeo_P3.checked) {
    Axis0.innerText = 'R'; Axis1.innerText = 'G'; Axis2.innerText = 'B';
    out_space = kP3Linear;
  }
  if (RadioGeo_Rec2020.checked) {
    Axis0.innerText = 'R'; Axis1.innerText = 'G'; Axis2.innerText = 'B';
    out_space = kRec2020Linear;
  }
  if (RadioGeo_OkLab.checked || RadioGeo_Rec2020YUV.checked) {
    moveElementToPoint(AxisOrigin, matrixModelViewProjection, [-0.08, 0.5, 0.5, 1]);
    moveElementToPoint(Axis0,      matrixModelViewProjection, [1, 0.5, 0.5, 1]);
    moveElementToPoint(Axis1,      matrixModelViewProjection, [0, 1,   0.5, 1]);
    moveElementToPoint(Axis2,      matrixModelViewProjection, [0, 0.5,   1, 1]);
    Axis0.innerText = 'L=1'; Axis1.innerText = 'a=0.5'; Axis2.innerText = 'b=0.5';

    if (RadioGeo_OkLab.checked)
      out_space = kOkLab;
  }
  if (RadioGeo_XYZ.checked) {
    Axis0.innerText = 'X'; Axis1.innerText = 'Y'; Axis2.innerText = 'Z';
    out_space = kXYZ;
  }
  if (RadioGeo_Rec2020YUV.checked) {
    Axis0.innerText = 'Y'; Axis1.innerText = 'U'; Axis2.innerText = 'V';
    out_space = kRec2020YUV;
  }

  let gamut_space = kSRGB;
  if (RadioVolume_sRGB.checked)          gamut_space = kSRGBLinear;
  if (RadioVolume_P3.checked)            gamut_space = kP3Linear;
  if (RadioVolume_Rec2020.checked)       gamut_space = kRec2020Linear;

  gl.useProgram(gamut_program);
  gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixProjection'), false,
                      matrixProjection);
  gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixModelView'), false,
                      matrixModelView);
  gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixSubModel'), false, matrixIdentity());

  gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [1, 1, 1, 1]);
  gl.uniform1i(gl.getUniformLocation(gamut_program, 'texture_xyzd50_lambda'), 0);
  gl.uniform1i(gl.getUniformLocation(gamut_program, 'output_position_type'), out_space);
  gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_discard'), 0);
  gl.uniform1f(gl.getUniformLocation(gamut_program, 'tonemap_hdr_headroom'), DisplayHdrHeadroom.value);

  gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 0);
  if (RadioGamutMap_Clamp.checked) {
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 1);
  }
  if (RadioGamutMap_CSS.checked) {
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 2);
  }
  if (RadioGamutMap_L2.checked) {
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 3);
  }
  if (RadioGamutMap_Y.checked) {
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 4);
  }


  const draw_sdr_solid = GamutRender_Solid.checked || GamutRender_SdrSolid_HdrWireframe.checked;
  const draw_hdr_solid = GamutRender_Solid.checked;

  // Draw the gamut
  {

    // Solid
    {
      gl.uniform1i(gl.getUniformLocation(gamut_program, 'input_position_type'), gamut_space);
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [1, 1, 1, 1]);
      gl.enable(gl.CULL_FACE);

      // HDR
      const slice_hdr = draw_hdr_solid && (RadioSlice_HDR.checked || RadioSlice_All.checked);
      if (draw_hdr_solid) {
        gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'),
                      slice_hdr ? slice_vector : no_slice_vector);

        gl.uniform1f(gl.getUniformLocation(gamut_program, 'input_hdr_headroom'), ContentHdrHeadroom.value);
        drawCube(gamut_program, null, 1.0);
      }

      // SDR
      const slice_sdr = draw_sdr_solid && RadioSlice_All.checked;
      if (draw_sdr_solid) {
        gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'),
                      slice_sdr ? slice_vector : no_slice_vector);
        gl.uniform1f(gl.getUniformLocation(gamut_program, 'input_hdr_headroom'), 1.0);
        drawCube(gamut_program, null, 1.0);
      }


      gl.disable(gl.CULL_FACE);
    }

    // Don't draw the slicing plane in auto mode if:
    // - we're looking at the wireframe
    // - we're not slicing anything
    let draw_plane = true;
    if (RadioPlane_Auto.checked) {
      if (RadioSlice_None.checked) {
        draw_plane = false;
      }
      if (GamutRender_Wireframe.checked) {
        draw_plane = false;
      }
    }

    if (draw_plane) {
      // Draw the full plane only when selected.
      let gamut_map_discard = true;
      if (RadioPlane_Plane.checked) {
        gamut_map_discard = false;
      }

      // Determine if we're drawing the big plane or small plane.
      let gamut_map_headroom = 1.0;
      if (RadioPlane_HDR.checked) {
        // Explicity requested.
        gamut_map_headroom = ContentHdrHeadroom.value;
      }
      if (RadioPlane_Auto.checked) {
        // In auto mode and we're both rendering and slicing the HDR gamut.
        if (GamutRender_Solid.checked) {
          if (RadioSlice_HDR.checked || RadioSlice_All.checked) {
            gamut_map_headroom = ContentHdrHeadroom.value;
          }
        }
      }

      let plane_scale = 1.0;
      if (!RadioPlane_Plane.checked) {
        plane_scale = Math.max(gamut_map_headroom, 4.0);
      }


    // Draw the slicing plane.
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'input_position_type'), out_space);
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_space'), gamut_space);
    gl.uniform1f(gl.getUniformLocation(gamut_program, 'gamut_map_headroom'), gamut_map_headroom);
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_discard'), gamut_map_discard);
    gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'), no_slice_vector);

    let matrices = [matrixIdentity()]
    matrices.push(slice_matrix);
    
    gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixSubModel'), false, matrixConcat(matrices));

    gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [1, 1, 1, 1]);
    drawPlane(gamut_program);
    }

    gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixSubModel'), false, matrixIdentity());
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_type'), 0);

  }

  gl.drawBuffers([gl.COLOR_ATTACHMENT0]);

  {
    // Wireframe
    gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [0, 0, 0, 0]);
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'input_position_type'), gamut_space);
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_discard'), 0);
    gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixSubModel'), false, matrixIdentity());

    // SDR
    // - draw when using wireframe
    // - draw, sliced, when slicing SDR
    if (GamutRender_Wireframe.checked || RadioSlice_All.checked) {
      let slice = !GamutRender_Wireframe.checked;
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'),
                    slice ? flip_slice_vector : no_slice_vector);
      drawCube(gamut_program, kGrid1x1, 1.0);
    }

    // HDR
    let hdr_wire_draw = true;
    if (ContentHdrHeadroom.value == 1.0) {
      // When headroom is 1, this is redundant with SDR.
      hdr_wire_draw = false;
    }
    if (GamutRender_Solid.checked) {
      if (!RadioSlice_HDR.checked && !RadioSlice_All.checked) {
        hdr_wire_draw = false;
      }
    }
    if (hdr_wire_draw) {
      let slice = !(GamutRender_Wireframe.checked || GamutRender_SdrSolid_HdrWireframe.checked);
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'),
                    slice ? flip_slice_vector : no_slice_vector);

      gl.uniform1f(gl.getUniformLocation(gamut_program, 'input_hdr_headroom'), ContentHdrHeadroom.value);
      drawCube(gamut_program, kGrid1x1, 1.0);
      gl.uniform1f(gl.getUniformLocation(gamut_program, 'input_hdr_headroom'), 1.0);
    }
  }

  // Draw the spectrum
  if (!RadioSpectrum_None.checked) {
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'input_position_type'), kWavelength);
    gl.uniform1i(gl.getUniformLocation(gamut_program, 'gamut_map_discard'), 0);
    gl.uniformMatrix4fv(gl.getUniformLocation(gamut_program, 'matrixSubModel'), false, matrixIdentity());
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture_xyzd50_lambda);

    if (SliceSpectrum.checked) {
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'), slice_vector);
    } else {
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'slice_vector'), no_slice_vector);
    }

    if (RadioSpectrum_Wire.checked) {
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [0, 0, 0, 1]);
    } else {
      gl.uniform4fv(gl.getUniformLocation(gamut_program, 'color'), [1, 1, 1, 1]);
    }
    drawGrid(gamut_program, kGrid32x8);
  }

  // Draw the coordinate system.
  gl.drawBuffers([gl.COLOR_ATTACHMENT0]);
  {
    gl.useProgram(black_program);
    gl.uniformMatrix4fv(gl.getUniformLocation(black_program, 'matrixProjection'), false,
                        matrixProjection);
    gl.uniformMatrix4fv(gl.getUniformLocation(black_program, 'matrixModelView'), false,
                        matrixModelView);
    gl.uniform4fv(gl.getUniformLocation(black_program, 'color'), [0.90, 0.90, 0.90, 1.0]);
    drawCube(black_program, kGrid1x1);
  }
}

let draw = function() {
  canvas.width  = fbo_width;
  canvas.height = fbo_height;
  canvas.style = 'width:640px; height:480px; border:1px solid black;';

  gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
  drawToFbo(fbo_width, fbo_height);

  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.drawBuffers([gl.BACK]);

  gl.disable(gl.DEPTH_TEST);
  gl.disable(gl.BLEND);

  gl.useProgram(blit_program);

  if (1)
  {
    let positions = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positions);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

    let positionLocation = gl.getAttribLocation(blit_program, 'position');
    gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(positionLocation);

    let indices = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);

    gl.uniform2fv(gl.getUniformLocation(blit_program, 'viewport'), [640, 480]);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture_color);
    gl.uniform1i(gl.getUniformLocation(blit_program, 'texture_color'), 0);

    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, texture_normal);
    gl.uniform1i(gl.getUniformLocation(blit_program, 'texture_normal'), 1);
 
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  }

  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, null);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, null);
}


function doMouseDown(evt) {
  if (dragging)
     return;
  dragging = true;
  dragging_shift = evt.shiftKey;
  document.addEventListener("mousemove", doMouseDrag, false);
  document.addEventListener("mouseup", doMouseUp, false);
  var box = canvas.getBoundingClientRect();
  dragging_last_x = window.pageXOffset + evt.clientX - box.left;
  dragging_last_y = window.pageYOffset + evt.clientY - box.top;
}

function doMouseDrag(evt) {
  if (!dragging)
     return;
  var box = canvas.getBoundingClientRect();
  var x = window.pageXOffset + evt.clientX - box.left;
  var y = window.pageYOffset + evt.clientY - box.top;

  var dx = x - dragging_last_x;
  var dy = y - dragging_last_y;

  if (dragging_shift) {
    view_z += 0.05 * dy;
  } else {
    view_rotation_y += dx;
    view_rotation_x += dy;
  }

  dragging_last_x = x;
  dragging_last_y = y;

  draw();
}

function doMouseUp(evt) {
  if (!dragging) {
    return;
  }
  document.removeEventListener("mousemove", doMouseDrag, false);
  document.removeEventListener("mouseup", doMouseUp, false);
  dragging = false;
}

let makeSpectrum = function() {
  let texture = gl.createTexture();
  let width = data_xyzd50_lambda.length / 4;
  let height = 1;

  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, width, height, 0, gl.RGBA, gl.FLOAT, data_xyzd50_lambda);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  texture_xyzd50_lambda = texture;
}

let onChange = function() {
  ContentHdrHeadroomValue.value = ContentHdrHeadroom.value;
  DisplayHdrHeadroomValue.value = DisplayHdrHeadroom.value;
  updateSlice();
  draw();
}

let initializeGL = function() {
  canvas = document.getElementById('Canvas');
  canvas.addEventListener("mousedown", doMouseDown, false);

  let saveCanvas = function() {
    draw();

    let mime_type = "image/jpeg";
    let download_link = document.createElement('a');
    let data_url = canvas.toDataURL(mime_type);
 
    download_link.download = 'out.png';
    download_link.href = data_url;
    download_link.dataset.downloadurl = [mime_type, download_link.download, download_link.href].join(':');
 
    document.body.appendChild(download_link);
    download_link.click();
    document.body.removeChild(download_link);
  }
  ButtonSave.addEventListener('click', saveCanvas);

  let warningsText = '';
  gl = canvas.getContext('webgl2',  {antialias:false});
  gl.getExtension('EXT_color_buffer_float');
  if (`drawingBufferStorage` in gl) {
    gl.drawingBufferStorage(gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
  } else {
    warningsText += 'Experimental WebGL API not found (drawingBufferStorage)!<br>'
  }
  if (`configureHighDynamicRange` in canvas) {
    canvas.configureHighDynamicRange({ mode:'extended' });
  } else {
    warningsText += 'Experimental HDR Canvas API not found (configureHighDyanmicRange)!<br>'
  }

  if (warningsText == '') {
  } else {
    warningsText += 'Experimental features missing: Enable "Experimental Web Platform Features" in chrome://flags';
 
    let warnings = document.getElementById('Warnings');
    warnings.hidden = false;
    warnings.style = 'color:#BC0000;';
    warnings.innerHTML = '<strong>' + warningsText + '</strong>';

    // Force fallback to simulated HDR?!?!?
  }

  {
    fbo_width = 640;
    fbo_height = 480;

    texture_color = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture_color);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, fbo_width, fbo_height, 0, gl.RGBA, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    texture_normal = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture_normal);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, fbo_width, fbo_height, 0, gl.RGBA, gl.FLOAT, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

    renderbuffer_depth = gl.createRenderbuffer();
    gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer_depth);
    gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, fbo_width, fbo_height);
    gl.bindRenderbuffer(gl.RENDERBUFFER, null);

    fbo = gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture_color, 0);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, texture_normal, 0);
    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer_depth);
    if (gl.FRAMEBUFFER_COMPLETE != gl.checkFramebufferStatus(gl.FRAMEBUFFER)) {
      throw('Incomplete framebuffer');
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  }

  makeSpectrum();

  blit_program = compileShader(gl, blit_vs, blit_fs);
  black_program = compileShader(gl, black_vs, black_fs);
  gamut_program = compileShader(gl, gamut_vs, gamut_fs);
  makePlane();
}

function main() {
  initializeGL();
  updateSlice();
  draw();
}

</script>
<body onload='main()'>

<p id='Warnings' hidden=true></p>

<p>
<b>Gamut</b>

<div>
Gamut volume color space

<input type="radio" name="volume" onchange='onChange();' id="RadioVolume_sRGB">
<label for="RadioVolume_sRGB">sRGB</label>

<input type="radio" name="volume" onchange='onChange();' id="RadioVolume_P3" checked>
<label for="RadioVolume_P3">P3</label>

<input type="radio" name="volume" onchange='onChange();' id="RadioVolume_Rec2020">
<label for="RadioVolume_Rec2020">Rec2020</label>
</div>

<div>
Geometric coordinate color space

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_sRGB">
<label for="RadioGeo_sRGB">sRGB</label>

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_P3">
<label for="RadioGeo_P3">P3</label>

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_Rec2020">
<label for="RadioGeo_Rec2020">Rec2020</label>

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_OkLab" checked>
<label for="RadioGeo_OkLab">OkLab</label>

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_XYZ">
<label for="RadioGeo_XYZ">XYZD50</label>

<input type="radio" name="geo" onchange='onChange();' id="RadioGeo_Rec2020YUV">
<label for="RadioGeo_Rec2020YUV">Rec2020 YUV</label>
</div>
</p>

<p>
<b>HDR</b>

<div>
<label for="ContentHdrHeadroom">Content HDR Headroom</label>
<input id="ContentHdrHeadroom" type="range" min="1" max="5" step=0.01 value="1.0" oninput='onChange();' onchange='onChange();'/>
<output id="ContentHdrHeadroomValue">1</output>
<br>
<label for="DisplayHdrHeadroom">Tonemap HDR Headroom</label>
<input id="DisplayHdrHeadroom" type="range" min="1" max="5" step=0.01 value="5.0" oninput='onChange();' onchange='onChange();'/>
<output style='width:20px;' id="DisplayHdrHeadroomValue">5</output>
</div>
</p>

<p>
<b>Rendering</b>

<div>
Slicing plane:
<label for="SliceAxis">Axis</label>
<input id="SliceAxis" type="number" min="0" max="3" value="1" onchange='onChange();'/>

<label for="SliceValue">Value</label>
<input id="SliceValue" type="range" min="0" max="1" step=0.001 value="0.5" oninput='onChange();' onchange='onChange();'/>

<input id="SliceFlip" type="checkbox" onchange='onChange();'/>
<label for="SliceFlip">Flip</label>
</div>
</p>

<div>
Slice:
<input type="radio" name="discard" onchange='onChange();' id="RadioSlice_None">
<label for="RadioSlice_None">Nothing</label>

<input type="radio" name="discard" onchange='onChange();' id="RadioSlice_All" checked>
<label for="RadioSlice_All">Everything</label>

<input type="radio" name="discard" onchange='onChange();' id="RadioSlice_HDR">
<label for="RadioSlice_HDR">HDR only</label>
</div>

<div>
Slicing plane: 
<input type="radio" name="plane" onchange='onChange();' id="RadioPlane_Auto" checked>
<label for="RadioPlane_Auto">Auto</label>

<input type="radio" name="plane" onchange='onChange();' id="RadioPlane_SDR">
<label for="RadioPlane_SDR">SDR</label>

<input type="radio" name="plane" onchange='onChange();' id="RadioPlane_HDR">
<label for="RadioPlane_HDR">HDR</label>

<input type="radio" name="plane" onchange='onChange();' id="RadioPlane_Plane">
<label for="RadioPlane_Plane">Full</label>
</div>
</p>

<div>
Gamut:

<input type="radio" name="gamut" onchange='onChange();' id="GamutRender_Wireframe">
<label for="GamutRender_Wireframe">Wire</label>

<input type="radio" name="gamut" onchange='onChange();' id="GamutRender_SdrSolid_HdrWireframe" checked>
<label for="GamutRender_SdrSolid_HdrWireframe">SDR (HDR wire)</label>

<input type="radio" name="gamut" onchange='onChange();' id="GamutRender_Solid">
<label for="GamutRender_Solid">HDR (and SDR)</label>
</div>

<div>
Gamut mapping:
<input type="radio" name="gamut_map" onchange='onChange();' id="RadioGamutMap_None" checked>
<label for="RadioGamutMap_None">None</label>

<input type="radio" name="gamut_map" onchange='onChange();' id="RadioGamutMap_CSS">
<label for="RadioGamutMap_CSS">CSS</label>

<input type="radio" name="gamut_map" onchange='onChange();' id="RadioGamutMap_Clamp">
<label for="RadioGamutMap_Clamp">Clamp</label>

<input type="radio" name="gamut_map" onchange='onChange();' id="RadioGamutMap_L2">
<label for="RadioGamutMap_L2">L2</label>

<input type="radio" name="gamut_map" onchange='onChange();' id="RadioGamutMap_Y">
<label for="RadioGamutMap_Y">Y</label>
</div>

<div>
Spectral colors:

<input type="radio" name="spectrum" onchange='onChange();' id="RadioSpectrum_None" checked>
<label for="RadioSpectrum_None">Hide</label>

<input type="radio" name="spectrum" onchange='onChange();' id="RadioSpectrum_Wire">
<label for="RadioSpectrum_Wire">Wire</label>

<input type="radio" name="spectrum" onchange='onChange();' id="RadioSpectrum_Color">
<label for="RadioSpectrum_Color">Color</label>

<input hidden id="SliceSpectrum" type="checkbox" onchange='onChange();'/>
<label hidden for="SliceSpectrum">Slice</label>
</div>

<p>
<div id="wrapper">
  <p id="AxisOrigin" style="user-select:none; position: absolute; width:16px; height:16; z-index:1; text-align:center;">0</p>
  <p id="Axis0"      style="user-select:none; position: absolute; width:16px; height:16; z-index:1; text-align:center;">R</p>
  <p id="Axis1"      style="user-select:none; position: absolute; width:16px; height:16; z-index:2; text-align:center;">G</p>
  <p id="Axis2"      style="user-select:none; position: absolute; width:16px; height:16; z-index:3; text-align:center;">B</p>

<p><button type="button" id="ButtonSave">Save Canvas</button></p>

<canvas id='Canvas' width='640' height='480'>
</canvas>
</div>
</p>

</body>
</html>
