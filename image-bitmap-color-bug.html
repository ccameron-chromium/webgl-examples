<html>
<head>
<script>
async function doDrawImage(elementId, image) {
  let element_2d = document.getElementById(elementId);
  let ctx = element_2d.getContext("2d", {colorSpace: 'display-p3'});
  ctx.drawImage(image, 0, 0, 128, 128);

  let element_gl = document.getElementById(elementId + "_GL");
  if (!element_gl)
    return;


  let gl = element_gl.getContext("webgl2");
  if (!('unpackColorSpace' in gl)) {
    // Safari doesn't support unpackColorSpace yet.
    return;
  } else {
    gl.unpackColorSpace = 'display-p3';
    gl.drawingBufferColorSpace = 'display-p3';
  }


  let tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(
      gl.TEXTURE_2D, 0, gl.RGBA, image.width, image.height, 0,
      gl.RGBA, gl.UNSIGNED_BYTE, image);
  gl.texParameteri(
      gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(
      gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(
      gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    
  const vs = `attribute vec2 a_position;
              varying vec2 v_texcoord;
              void main() {
                v_texcoord = (a_position + vec2(1.0, 1.0)) * 0.5;
                v_texcoord.y = 1.0 - v_texcoord.y;
                gl_Position = vec4(a_position, 0.0, 1.0);
              }`;

  const fs = `precision mediump float;
              uniform sampler2D tex;
              varying vec2 v_texcoord;


              void main() {
                gl_FragColor = texture2D(tex, v_texcoord);
              }`;

  let compileShader = function(vertCode, fragCode) {
    let vertShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertShader, vertCode);
    gl.compileShader(vertShader);
       
    let fragShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragShader, fragCode); 
    gl.compileShader(fragShader);
    
    let shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertShader);
    gl.attachShader(shaderProgram, fragShader);
    gl.linkProgram(shaderProgram);
    return shaderProgram;
  }
  
  let program = compileShader(vs, fs);
  gl.useProgram(program);

  {
    const vertices = [-1.0, -1.0, -1.0,  1.0, 1.0,  1.0,
                       1.0,  1.0, 1.0, -1.0, -1.0, -1.0];
    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices),
                       gl.STATIC_DRAW);

    const attribLocation = gl.getAttribLocation(program, 'a_position');
    gl.enableVertexAttribArray(attribLocation);
    gl.vertexAttribPointer(attribLocation, 2, gl.FLOAT, false, 0, 0);
  }

  gl.drawArrays(gl.TRIANGLES, 0, 6);


}

window.onload = function() {
  var url = "red-p3-on-srgb-in-2020.png";
  var image = new Image();
  image.onload = function() {
    doDrawImage("CanvasA", image);

    createImageBitmap(image).then((imageBitmap) => {
      doDrawImage("CanvasB", imageBitmap);
    });

    createImageBitmap(image, {colorSpaceConversion:"none"}).then((imageBitmap) => {
      doDrawImage("CanvasC", imageBitmap);
    });

    createImageBitmap(image, {colorSpaceConversion:"none", resizeWidth:500, resizeHeight:500}).then((imageBitmap) => {
      doDrawImage("CanvasD", imageBitmap);
    });
  }
  image.src = url;

  var xhr = new XMLHttpRequest();
  xhr.open("GET", url);
  xhr.responseType = 'blob';
  xhr.send();
  xhr.onload = function() {
    createImageBitmap(xhr.response).then((imageBitmap) => {
      doDrawImage("CanvasE", imageBitmap);
    });
    createImageBitmap(xhr.response, {colorSpaceConversion:"none"}).then((imageBitmap) => {
      doDrawImage("CanvasF", imageBitmap);
    });
  };
};
</script>
</head>
<body>

<table>
<tr>
<td width="150"> <img width="128" height="128" src="red-p3-on-srgb-in-2020.png"> </td>
<td width="150"> <img width="128" height="128" src="red-p3-on-srgb-in-2020.png"> </td>
<td>
An image as an HTMLImageElement. 

<ul>
<li> The image background is color(srgb 1 0 0), with a square that is color(display-p3 1 0 0) in the foreground. </li>
<li> The image's color space is Rec2020. </li>
</ul>

</td>
</tr>

<tr>
<td width="150"> 2D </td>
<td width="150"> WebGL2 </td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasA" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasA_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same HTMLImageElement to a P3 canvas.
  <ul>
  <li>
  On Chrome, the image is appears correctly (is not clamped to the sRGB gamut).
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  Safari's WebGL implementation does not support unpackColorSpace, so the WebGL column is blank.
  </li>
  </ul>
</td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasB" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasB_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same HTMLImageElement to a P3 canvas via createImageBitmap, having not specified colorSpaceConversion (so, getting the "default" behavior).
  <ul>
  <li>
  On Chrome, the image gets clamped to the sRGB gamut, and so the image appears as solid red.
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  </li>
  </ul>
</td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasC" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasC_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same HTMLImageElement to a P3 canvas via createImageBitmap, having specified {colorSpaceConversion:"none"}.
  <ul>
  <li>
  On Chrome, the image is unaffected by the flag.
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  </li>
  </ul>
</td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasD" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasD_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same HTMLImageElement to a P3 canvas via createImageBitmap, having specified {colorSpaceConversion:"none", resizeWidth:500, resizeHeight:500}.
  <ul>
  <li>
  On Chrome, the image's color space (ICC profile) is ignored, its pixels are interpreted as being sRGB, and so the image appears unsaturated.
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  </li>
  </ul>
</td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasE" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasE_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same image, fetched as a Blob, to a P3 canvas via createImageBitmap, having not specified colorSpaceConversion (so, getting the "default" behavior).
  <ul>
  <li>
  On Chrome, the image gets clamped to the sRGB gamut, and so the image appears as solid red.
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  </li>
  </ul>
</td>
</tr>

<tr>
<td width="150"> <canvas id="CanvasF" width="128" height="128"></canvas> </td>
<td width="150"> <canvas id="CanvasF_GL" width="128" height="128"></canvas> </td>
<td>
  Drawing that same image, fetched as a Blob, to a P3 canvas via createImageBitmap, having specified {colorSpaceConversion:"none"}.
  <ul>
  <li>
  On Chrome, the image's color space (ICC profile) is ignored, the pixels are interpreted as being sRGB, and so the image appears solid red.
  </li>
  <li>
  On Safari, the image is unaffected by the flag.
  </li>
  </ul>
</td>
</tr>

</table>

</body>
</html>
