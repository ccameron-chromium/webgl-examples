<html>
<head>
<script>
var canvas;
var gl;
var program;
var filename;

var texture;
var texture_w;
var texture_h;
var texture_pixels;

var hlg_ootf_gamma = 1.2;

var viewport_w;
var viewport_h;
var save_requested = false;

var saved_settings1 = {};
var saved_settings2 = {};

let linearToSrgb = function (x) {
  let a = 1.1371188301409823;
  let c = 12.919999999992248;
  let d = 0.003130800090713953;
  let e = -0.05499994754780801;
  let g = 0.4166666666666667;
  if (x < d)
    return c*x;
  return Math.pow(a*x, g) + e;
}

let pqSignalToNits = function(v) {
  const c1 =  107.0 / 128.0;
  const c2 = 2413.0 / 128.0;
  const c3 = 2392.0 / 128.0;
  const m1 = 1305.0 / 8192.0;
  const m2 = 2523.0 / 32.0;
  const p = Math.pow(Math.min(Math.max(v, 0.0), 1.0), 1.0 / m2);
  return 10000.0 * Math.pow(Math.max(p - c1, 0.0) / (c2 - c3 * p), 1.0 / m1);
}

const kGamutMapNone = 0;
const kGamutMapMark = 1;
const kGamutMapClamp = 2;
const kGamutMapScaleRGB = 3;
const kGamutMapScaleUV = 4;
const kGamutMapL2RGB = 5;
const kGamutMapOkLabConstantH = 6;

const kToneMapNone = 0;
const kToneMapNativePQ = 1;
const kToneMapNativeHLG = 2;
const kToneMapClamp = 3;
const kToneMapReinhard = 4;
const kToneMapBT2408 = 5;
const kToneMapBT2446A = 6;
const kToneMapBT2446C = 7;
const kToneMapBT2100HLG = 8;
const kToneMapHLGAs22 = 9;
const kToneMapBT2446A_redo = 10;

const ToneMapInputMaxRGB = 0;
const ToneMapInputYRGB = 1;
const ToneMapInputRpGpBp = 2;
const ToneMapInputMix = 3;

const kTransferSRGB = 0;
const kTransferHLG = 1;
const kTransferPQ = 2;
const kTransferPQ_G = 3;

const kGamutSRGB = 0;
const kGamutP3 = 1;
const kGamutRec2020 = 2;

const fs_constants = `
  int kGamutMapNone = 0;
  int kGamutMapMark = 1;
  int kGamutMapClamp = 2;
  int kGamutMapScaleRGB = 3;
  int kGamutMapScaleUV = 4;
  int kGamutMapL2RGB = 5;
  int kGamutMapOkLabConstantH = 6;

  int kToneMapNone = 0;
  int kToneMapNativePQ = 1;
  int kToneMapNativeHLG = 2;
  int kToneMapClamp = 3;
  int kToneMapReinhard = 4;
  int kToneMapBT2408 = 5;
  int kToneMapBT2446A = 6;
  int kToneMapBT2446C = 7;
  int kToneMapBT2100HLG = 8;
  int kToneMapHLGAs22 = 9;
  int kToneMapBT2446A_redo = 10;

  int ToneMapInputMaxRGB = 0;
  int ToneMapInputYRGB = 1;
  int ToneMapInputRpGpBp = 2;
  int ToneMapInputMix = 3;

  int kTransferSRGB = 0;
  int kTransferHLG = 1;
  int kTransferPQ = 2;
  int kTransferPQ_G = 3;

  int kGamutSRGB = 0;
  int kGamutP3 = 1;
  int kGamutRec2020 = 2;
  int kFakeGamutOkLab = 3;
  `

const vs = `attribute vec2 position;
            varying vec2 texcoord;
            void main() {
              texcoord = vec2(0.5+0.5*position.x, 0.5-0.5*position.y);
              gl_Position = vec4(position, 0.0, 1.0);
            }`;
const fs = `
  precision highp float;
  uniform sampler2D texture;
  uniform float clli_max_nits;
  uniform float ndwl_white_nits;
  uniform float hlg_ootf_gamma;
  uniform int tonemap_mode;
  uniform int tonemap_weight_before;
  uniform float tonemap_weight_maxRGB;
  uniform float tonemap_weight_RpGpBp;
  uniform float tonemap_weight_YRGB;
  uniform int gamut_map_mode;
  uniform int final_gamut_mode;
  uniform int final_gamut;
  uniform int signal_transfer;
  uniform int signal_primaries;
  uniform int use_bgr;
  varying vec2 texcoord;

  ` + fs_constants + `

  // Primary conversion matrices.
  mat3 p3_to_xyzd50 = mat3( 0.515102,  0.241182,  -0.00104941,
                            0.291965,  0.692236,   0.0418818,
                            0.157153,  0.0665819,  0.784378);
  mat3 srgb_to_xyzd50 = mat3( 0.43606567, 0.2224884,  0.01391602,
                              0.38514709, 0.71687317, 0.09707642,
                              0.14306641, 0.06060791, 0.71409607);
  mat3 rec2020_to_xyzd50 = mat3( 0.673459,  0.279033,   -0.00193139,
                                 0.165661,  0.675338,    0.0299794,
                                 0.1251,    0.0456288,   0.797162);
  mat3 xyzd50_to_rec2020 = mat3( 1.6472752,  -0.68261762,  0.02966273,
                                -0.39360248,  1.64761778, -0.06291669,
                                -0.23598029,  0.01281627,  1.25339643);
  mat3 xyzd50_to_p3 = mat3( 2.40404516, -0.84222838,  0.04818706,
                           -0.98989869,  1.79885051, -0.09737385,
                           -0.39763172,  0.01604817,  1.27350664);
  mat3 xyzd50_to_srgb = mat3( 3.13411215, -0.97878729,  0.07198304,
                             -1.61739246,  1.91627959, -0.22898585,
                             -0.4906334,   0.03345471,  1.40538513);
  mat3 xyzd50_to_xyzd65 = mat3( 0.95547345, -0.02836971,  0.01231400,
                               -0.02309854,  1.00999546, -0.02050770,
                                0.06325931,  0.02104140,  1.33036594);
  mat3 xyzd65_to_xyzd50 = mat3( 1.04792976,  0.02962780, -0.00924303,
                                0.02294695,  0.99043437,  0.01505523,
                               -0.05019232, -0.01707377,  0.75187428);
  mat3 xyzd65_to_lms = mat3( 0.81902244, 0.03298367, 0.04817720,
                             0.36190626, 0.92928685, 0.26423952,
                            -0.12887378, 0.03614467, 0.63354783);
  mat3 lms_to_xyzd65 = mat3( 1.22687987, -0.04057576, -0.07637295,
                            -0.55781500,  1.11228683, -0.42149332,
                             0.28139105, -0.07171107,  1.58692402);
  mat3 lms_to_oklab = mat3( 0.21045426,  1.97799850,  0.02590404,
                            0.79361779, -2.42859221,  0.78277177,
                           -0.00407205,  0.45059371, -0.80867577);
  mat3 oklab_to_lms = mat3( 1.00000000,  1.00000001,  1.00000005,
                            0.39633779, -0.10556134, -0.08948418,
                            0.21580376, -0.06385417, -1.29148554);

  // Y_rec2020 is the luminance vector in rec2020 primaries.
  vec3 rec2020_rgb_to_yuv(vec3 rgb) {
    mat4 rgb_to_yuv = mat4(
        0.262700, -0.139630,  0.500000,  0.0,
        0.678000, -0.360370, -0.459786,  0.0,
        0.059300,  0.500000, -0.040214,  0.0,
        0.000000,  0.500122,  0.500122,  1.0);
    return (rgb_to_yuv * vec4(rgb, 1.0)).rgb;
  }
  vec3 rec2020_yuv_to_rgb(vec3 yuv) {
    mat4 yuv_to_rgb =  mat4(
         1.0,         1.0,         1.0,         0.0,
        -0.00000089, -0.16455278,  1.88139998,  0.0,
         1.47459975, -0.57135301, -0.00000024,  0.0,
        -0.73747933,  0.36804268, -0.9409294,   1.0);
    return (yuv_to_rgb * vec4(yuv, 1.0)).rgb;
  }

  vec3 xyzd50_to_oklab(vec3 xyzd50) {
    vec3 lms = xyzd65_to_lms * xyzd50_to_xyzd65 * xyzd50;
    vec3 lms_cbrt = (sign(lms) * pow(abs(lms), vec3(1.0/3.0)));
    vec3 Lab = lms_to_oklab * lms_cbrt;
    return Lab;
  }

  vec3 oklab_to_xyzd50(vec3 Lab) {
    vec3 lms_cbrt = oklab_to_lms * Lab;
    vec3 lms = sign(lms_cbrt) * pow(abs(lms_cbrt), vec3(3.0));
    return xyzd65_to_xyzd50 * lms_to_xyzd65 * lms;
  }

  float srgbToLinear(float x) {
    if (x < 0.0)
      return 0.0;
    if (x > 1.0)
      return 1.0;
    if (x < 0.04045)
      return x / 12.92;
    return pow((x + 0.055)/1.055, 2.4);
  }
  float linearToSrgb(float x) {
    if (x < 0.003130800090713953)
      return 12.919999999992248*x;
    return pow(1.1371188301409823*x, 0.4166666666666667) - 0.05499994754780801;
  }
  vec3 srgbToLinear(vec3 c) {
    return vec3(srgbToLinear(c.r), srgbToLinear(c.g), srgbToLinear(c.b));
  }
  vec3 linearToSrgb(vec3 c) {
    return vec3(linearToSrgb(c.r), linearToSrgb(c.g), linearToSrgb(c.b));
  }

  float pqSignalToNits(float v) {
    float c1 =  107.0 / 128.0;
    float c2 = 2413.0 / 128.0;
    float c3 = 2392.0 / 128.0;
    float m1 = 1305.0 / 8192.0;
    float m2 = 2523.0 / 32.0;
    float p = pow(clamp(v, 0.0, 1.0), 1.0 / m2);
    return 10000.0 * pow(max(p - c1, 0.0) / (c2 - c3 * p), 1.0 / m1);
  }
  float pqNitsToSignal(float L) {
    float c1 =  107.0 / 128.0;
    float c2 = 2413.0 / 128.0;
    float c3 = 2392.0 / 128.0;
    float m1 = 1305.0 / 8192.0;
    float m2 = 2523.0 / 32.0;
    float v = pow(clamp(L / 10000.0, 0.0, 1.0), m1);
    return pow((c1 + c2 * v) / (1.0 + c3 * v), m2);
  }
  float pqNormalizedSignal(float L, float Lw, float Lb) {
    return (pqNitsToSignal(L)  - pqNitsToSignal(Lb)) /
           (pqNitsToSignal(Lw) - pqNitsToSignal(Lb));
  }

  float hlgOetfInv(float x) {
    const float a = 0.17883277;
    const float b = 1.0 - 4.0*a;
    const float c = 0.5 - a * log(4.0 * a);
    if (x <= 0.5) {
      return pow(x, 2.0) / 3.0;
    } else {
      return (exp((x - c) / a) + b) / 12.0;
    }
  }
  float hlgOetf(float x) {
    const float a = 0.17883277;
    const float b = 1.0 - 4.0*a;
    const float c = 0.5 - a * log(4.0 * a);
    float E = 12.0 * x;
    if (E < 1.0) {
      return 0.5 * sqrt(E);
    }
    return a * log(E - b) + c;
  }
  vec3 hlgOetf(vec3 c) {
    return vec3(hlgOetf(c.r), hlgOetf(c.g), hlgOetf(c.b));
  }

  float toneMapGainReinhard(float L, float Lc, float Ld) {
    if (Ld < Lc) {
      float a = Ld / (Lc*Lc);
      float b = 1.0 / Ld;
      return (1.0 + a*L) / (1.0 + b*L);
    }
    return 1.0;
  }

  // Content is in [Lb, Lw]
  // Display is [Lmin, Lmax]
  float toneMapGainBT2408(float L, float Lb, float Lw, float Lmin, float Lmax) {
    if (Lmax >= Lw) {
      return 1.0;
    }
    if (L >= Lw - 0.001) {
      return Lmax / L;
    }

    float Eprime = L;

    float E1 = pqNormalizedSignal(Eprime, Lw, Lb);
    float minLum = pqNormalizedSignal(Lmin, Lw, Lb);
    float maxLum = pqNormalizedSignal(Lmax, Lw, Lb);
    float KS = 1.5 * maxLum - 0.5;
    float b = minLum;

    float E2 = 0.0;
    if (E1 <= KS) {
      return 1.0;
      E2 = E1;
    } else {
      float TB1 = (E1 - KS) / (1.0 - KS);
      float TB2 = TB1 * TB1;
      float TB3 = TB2 * TB1;
      E2 = ( 2.0*TB3 - 3.0*TB2 + 1.0) * KS + \
           (     TB3 - 2.0*TB2 + TB1) * (1.0 - KS) + \
           (-2.0*TB3 + 3.0*TB2      ) * maxLum;
    }
    float E3 = E2 + b*pow(max(1.0 - E2, 0.0), 4.0);
    float E4 = E3 * (pqNitsToSignal(Lw) - pqNitsToSignal(Lb)) + pqNitsToSignal(Lb);
    return pqSignalToNits(E4) / Eprime;
  }

  vec3 toneMapBT2446a(vec3 RGB) {
    float L_HDR = clli_max_nits;
    float L_SDR = ndwl_white_nits;
    float rho_HDR = 1.0 + 32.0 * pow(L_HDR / 10000.0, 1.0/2.4);
    float rho_SDR = 1.0 + 32.0 * pow(L_SDR / 10000.0, 1.0/2.4);

    // A normalized (to L_HDR) full-range linear display-light HDR signal RGB.
    RGB /= L_HDR;
    RGB = clamp(RGB, 0.0, 1.0);

    float Rprime = pow(RGB.r, 1.0/2.4);
    float Gprime = pow(RGB.g, 1.0/2.4);
    float Bprime = pow(RGB.b, 1.0/2.4);

    float Yprime = 0.2627*Rprime + 0.6780*Gprime + 0.0593*Bprime;
    float Yprime_p = log(1.0 + (rho_HDR - 1.0)*Yprime) / log(rho_HDR);

    float Yprime_c = 0.0;
    if (Yprime_p < 0.0) {
      Yprime_c = 0.0;
    } else if (Yprime_p < 0.7399) {
      Yprime_c = 1.0770 * Yprime_p;
    } else if (Yprime_p < 0.9909) {
      Yprime_c = -1.1510 * pow(Yprime_p, 2.0) + 2.7811*Yprime_p - 0.6302;
    } else if (Yprime_p <= 1.0) {
      Yprime_c = 0.5 * Yprime_p + 0.5;
    } else {
      Yprime_c = 1.0;
    }

    float Yprime_SDR = (pow(rho_SDR, Yprime_c) - 1.0) / (rho_SDR - 1.0);

    return (pow(Yprime_SDR, 2.4) / Yprime) * RGB;

    float f_Yprime_SDR = Yprime_SDR / (1.1 * Yprime);

    float Cprime_b_TMO = f_Yprime_SDR * (Bprime - Yprime) / 1.8814;
    float Cprime_r_TMO = f_Yprime_SDR * (Rprime - Yprime) / 1.4746;

    float Yprime_TMO = Yprime_SDR - max(0.1 * Cprime_r_TMO, 0.0);

    vec3 YCbCr_TMO = vec3(Yprime_TMO, Cprime_b_TMO, Cprime_r_TMO);

    return rec2020_yuv_to_rgb(YCbCr_TMO);
  }
  

  float toneMapGainBT2446a(float Y_HDR, float L_HDR, float L_SDR) {
    float rho_hdr = 1.0 + 32.0 * pow(L_HDR / 10000.0, 1.0/2.4);
    float rho_sdr = 1.0 + 32.0 * pow(L_SDR / 10000.0, 1.0/2.4);
 
    // Y_HDR is "A normalized full-range linear display-light HDR signal"
    float Yprime = pow(Y_HDR / L_HDR, 1.0/2.4);
 
    float Yp_prime = log(1.0 + (rho_hdr - 1.0) * Yprime) / log(rho_hdr);
    float Yc_prime = 0.0;
    if (Yp_prime < 0.0) {
      Yc_prime = 0.0;
    } else if (Yp_prime < 0.7399) {
      Yc_prime = 1.0770 * Yp_prime;
    } else if (Yp_prime < 0.9909) {
      Yc_prime = -1.1510 * pow(Yp_prime, 2.0) + 2.7811*Yp_prime - 0.6302;
    } else if (Yp_prime <= 1.0) {
      Yc_prime = 0.5 * Yp_prime + 0.5;
    } else {
      Yc_prime = 1.0;
    }
    float Ysdr_prime = (pow(rho_sdr, Yc_prime) - 1.0) / (rho_sdr - 1.0);
 
    // This is not explicitly in the formulation, but I think was intended.
    float Ysdr = pow(Ysdr_prime, 2.4);
    return (Ysdr * L_SDR) / Y_HDR;
  }

  float toneMapGainBT2446c(float Y_hdr) {
      float k1 = 0.83802;
      float k2 = 15.09968;
      float k3 = 0.74204;
      float k4 = 78.99439;
      float HDR_ip = 58.5 / k1;

      float Y_sdr = 0.0;
      if (Y_hdr < HDR_ip) {
        Y_sdr = k1 * Y_hdr;
      } else {
        Y_sdr = k2 * log(Y_hdr / HDR_ip - k3) + k4;
      }
      const float kSdrMax = 120.0;
      if (Y_sdr > kSdrMax) {
        Y_sdr = kSdrMax;
      }
      Y_sdr *= ndwl_white_nits / kSdrMax;
      return Y_sdr / Y_hdr;
  }

  // Intersect the line segment between a and b with the unit cube.
  // Assumes that b is always inside the unit cube.
  vec3 intersectWithUnitCube(vec3 a, vec3 b) {
    float alpha = 1.0;
    for (int i = 0; i < 3; ++i) {
      if (a[i] > 1.0) {
        float alpha_i = (1.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      } else if (a[i] < 0.0) {
        float alpha_i = (0.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      }
    }
    alpha = max(alpha, 0.0);
    return alpha * a + (1.0 - alpha) * b;
  }

  vec3 hlgRefOotf(vec3 c) {
    float Y = rec2020_rgb_to_yuv(c).r;
    c *= pow(Y, 0.2);
    c *= 1000.0;
    return c;
  }
  vec3 hlgRefOotfInv(vec3 c) {
    c /= 1000.0;
    c = clamp(c, 0.0, 1.0);
    c *= pow(rec2020_rgb_to_yuv(c).r, -0.2 / 1.2);
    return c;
  }

  // Find alpha in [0, 1] that minimizes |c0 - (alpha*c1 + (1-alpha)*c2)|
  vec3 nearestPointOnSegment(vec3 c0, vec3 c1, vec3 c2) {
    // let u = c2 - c1
    // let v = c0 - c1
    // minimize dist2(c0, c1 + alpha*(c2 - c1)) =
    //          dist2(c0, c1 + alpha*u) =
    //          dot(alpha*u - v, alpha*u - v) =
    //          alpha^2 * dot(u, u) - alpha*2*dot(u, v) + dot(v, v)
    // this is minimized at alpha = dot(u, v) / dot(u, u)
    vec3 u = c2 - c1;
    vec3 v = c0 - c1;
    float a = dot(u, u);
    float b = 2.0 * dot(u, v);
    if (a <= 0.0) {
      return c0;
    }
    float alpha = clamp(dot(u, v) / a, 0.0, 1.0);
    return (1.0 - alpha) * c1 + alpha * c2;
  }

  vec3 convert(vec3 c, int from, int to) {
    if (from == to) {
      return c;
    }

    // Convert to XYZD50
    if (from == kGamutSRGB) {
      c = srgb_to_xyzd50 * c;
    }
    else if (from == kGamutP3) {
      c = p3_to_xyzd50 * c;
    }
    else if (from == kGamutRec2020) {
      c = rec2020_to_xyzd50 * c;
    }
    else if (from == kFakeGamutOkLab) {
      c = oklab_to_xyzd50(c);
    }

    // Convert from from XYZD50
    if (to == kGamutSRGB) {
      c = xyzd50_to_srgb * c;
    }
    else if (to == kGamutP3) {
      c = xyzd50_to_p3 * c;
    }
    else if (to == kGamutRec2020) {
      c = xyzd50_to_rec2020 * c;
    }
    else if (to == kFakeGamutOkLab) {
      c = xyzd50_to_oklab(c);
    }

    return c;
  }

  bool inUnitCube(vec3 c, float epsilon) {
    return c.r >= -epsilon && c.r <= 1.0 + epsilon &&
           c.g >= -epsilon && c.g <= 1.0 + epsilon &&
           c.b >= -epsilon && c.b <= 1.0 + epsilon;
  }

  vec3 gamutMapOkLabConstantH(vec3 c, int gamut) {
    if (inUnitCube(c, 0.0)) {
      return c;
    }
    vec3 Lab = convert(c, gamut, kFakeGamutOkLab);
    vec3 Loo = vec3(min(Lab.x, 1.0), 0.0, 0.0);
    float alpha0 = 0.0;
    float alpha1 = 1.0;
    for (int i = 0; i < 8; ++i) {
      float alpha_test = 0.5 * (alpha0 + alpha1);
      vec3 Lab_test = alpha_test * Lab + (1.0 - alpha_test) * Loo;
      vec3 c_test = convert(Lab_test, kFakeGamutOkLab, gamut);
      if (inUnitCube(c_test, 0.0)) {
        alpha0 = alpha_test;
      } else {
        alpha1 = alpha_test;
      }
    }
    float alpha_final = 0.5 * (alpha0 + alpha1);
    vec3 Lab_final = alpha_final * Lab + (1.0 - alpha_final) * Loo;
    return convert(Lab_final, kFakeGamutOkLab, gamut);
  }

  // Gamut map to |gamut| using |mode|. The input color |c| must be rec2020.
  vec3 gamutMap(vec3 c, int mode, int gamut) {
    if (mode == kGamutMapNone) {
      return c;
    }

    // Convert to the space for gamut mapping.
    c = convert(c, kGamutRec2020, gamut);

    if (mode == kGamutMapClamp) {
      c = clamp(c, 0.0, 1.0);
    }
    if (mode == kGamutMapMark) {
      if (!inUnitCube(c, 1.0 / 255.0)) {
        c = vec3(1.0, 0.0, 0.0);
      }
    }
    if (mode == kGamutMapScaleUV) {
      float Y = rec2020_rgb_to_yuv(c).r;
      c = intersectWithUnitCube(c, vec3(Y, Y, Y));
      c = clamp(c, 0.0, 1.0);
    }
    if (mode == kGamutMapScaleRGB) {
      c = intersectWithUnitCube(c, vec3(0.0, 0.0, 0.0));
      c = clamp(c, 0.0, 1.0);
    }
    if (mode == kGamutMapL2RGB) {
      // This is finding the nearest L2 point in RGB space that is in the
      // plane defined by black, white, and the color c itself.
      float M = max(max(c.r, c.g), c.b);
      if (M > 1.0) {
        vec3 u = vec3(1.0, 1.0, 1.0);
        vec3 v = u - (1.0/M) * c;
        vec3 w = (1.0 - 1.0/M) * c;
        float alpha = dot(v, w) / dot(v, v);
        c = ((1.0 - alpha)/M) * c + (alpha)*u;
      }
      c = clamp(c, 0.0, 1.0);
    }
    if (mode == kGamutMapOkLabConstantH) {
      c = gamutMapOkLabConstantH(c, gamut);
    }

    // Convert back to Rec2020.
    c = convert(c, gamut, kGamutRec2020);

    return c;
  }

  vec3 readTextureAsRec2100Nits() {
    vec3 c = texture2D(texture, texcoord).rgb;

    // Convert to linear.
    if (signal_transfer == kTransferSRGB) {
      c = srgbToLinear(c);
      c = ndwl_white_nits * c;
    }
    if (signal_transfer == kTransferPQ) {
      c = vec3(pqSignalToNits(c.r), pqSignalToNits(c.g), pqSignalToNits(c.b));
    }
    if (signal_transfer == kTransferHLG) {
      c = vec3(hlgOetfInv(c.r), hlgOetfInv(c.g), hlgOetfInv(c.b));
    }
    if (signal_transfer == kTransferPQ_G) {
      c = vec3(pqSignalToNits(c.r), pqSignalToNits(c.g), pqSignalToNits(c.b));

      float Y = rec2020_rgb_to_yuv(c).r / ndwl_white_nits;
      c *= pow(Y, 1.0/1.2 - 1.0);
    }

    // Convert from image primaries to rec2020 primaries.
    if (signal_primaries == 0) {
      c = xyzd50_to_rec2020 * srgb_to_xyzd50 * c;
    }
    if (signal_primaries == 1) {
      c = xyzd50_to_rec2020 * p3_to_xyzd50 * c;
    }

    // Apply the HLG OOTF (and scale up) in rec2020.
    if (signal_transfer == kTransferHLG) {
      c = hlgRefOotf(c);
    }

    return c;
  }

  float toneMapGain(float x) {
    if (tonemap_mode == kToneMapReinhard) {
      return toneMapGainReinhard(x, clli_max_nits, ndwl_white_nits);
    } else if (tonemap_mode == kToneMapBT2408) {
      // ITU-R BT.2408.
      return toneMapGainBT2408(x, 0.0, clli_max_nits, 0.0, ndwl_white_nits);
    } else if (tonemap_mode == kToneMapBT2446A) {
      // ITU-R BT.2446 Method A.
      return toneMapGainBT2446a(x, clli_max_nits, ndwl_white_nits);
    } else if (tonemap_mode == kToneMapBT2446C) {
      // ITU-R BT.2446 Method C.
      return toneMapGainBT2446c(x);
    }
    return 0.0;
  }

  vec3 computeGain(vec3 tonemap_input) {
    return vec3(toneMapGain(tonemap_input.r),
                toneMapGain(tonemap_input.g),
                toneMapGain(tonemap_input.b));
  }

  vec3 toneMapRec2100NitsToRec2020Linear(vec3 c) {
    // Clamp to the indicated maximum
    c = min(c, clli_max_nits);

    if (tonemap_mode == kToneMapNone) {
      c /= ndwl_white_nits;
    }
    else if (tonemap_mode == kToneMapClamp) {
      c /= ndwl_white_nits;
      c = max(c, vec3(0.0, 0.0, 0.0));
      c = min(c, vec3(1.0, 1.0, 1.0));
    }
    else if (tonemap_mode == kToneMapBT2100HLG) {
      // If the mode is ITU-R BT.2100, just apply the custom OOTF gamma.

      // Convert back to linear [0, 1] before the OOTF.
      c = hlgRefOotfInv(c);

      // Apply the specified gamma.
      float Y = rec2020_rgb_to_yuv(c).r;
      c *= pow(Y, hlg_ootf_gamma - 1.0);
    }
    else if (tonemap_mode == kToneMapHLGAs22) {
      vec3 c_rec2100hlg = hlgOetf(hlgRefOotfInv(c));
      c = pow(c_rec2100hlg, vec3(2.2, 2.2, 2.2));
    }
    else if (tonemap_mode == kToneMapBT2446A_redo) {
      c = toneMapBT2446a(c);
    }
    else if (tonemap_mode == kToneMapReinhard ||
             tonemap_mode == kToneMapBT2408   ||
             tonemap_mode == kToneMapBT2446A  ||
             tonemap_mode == kToneMapBT2446C) {
      // For curve-based tonemap functions, compute the per-channel inputs.
      vec3 tonemap_input_maxRGB =  vec3(max(max(c.r, c.g), c.b));
      vec3 tonemap_input_RpGpBp =  c;
      vec3 tonemap_input_YRGB   =  vec3(rec2020_rgb_to_yuv(c).r);

      vec3 gain;
      if (tonemap_weight_before == 1) {
        gain = computeGain(tonemap_weight_maxRGB * tonemap_input_maxRGB +
                           tonemap_weight_RpGpBp * tonemap_input_RpGpBp +
                           tonemap_weight_YRGB   * tonemap_input_YRGB);
      } else {
        gain = tonemap_weight_maxRGB * computeGain(tonemap_input_maxRGB) +
               tonemap_weight_RpGpBp * computeGain(tonemap_input_RpGpBp) +
               tonemap_weight_YRGB   * computeGain(tonemap_input_YRGB);
      }
      c *= gain;
      c /= ndwl_white_nits;
    } else {
      c *= 0.0;
    }

    // Perform gamut mapping in Rec2020.
    c = gamutMap(c, gamut_map_mode, kGamutRec2020);

    // Perform SDR gamut mapping.
    c = gamutMap(c, final_gamut_mode, final_gamut);

    return c;
  }

  void main() {
    // Treat everything as opaque. Just write RGB from here on.
    gl_FragColor.a = 1.0;

    vec3 c = readTextureAsRec2100Nits();

    // Clamp to the indicated maximum
    c = min(c, clli_max_nits);

    if (tonemap_mode == kToneMapNativePQ) {
      // For Native PQ, just write the value and return.
      vec3 c_rec2100pq = vec3(pqNitsToSignal(c.r), pqNitsToSignal(c.g), pqNitsToSignal(c.b));
      gl_FragColor.rgb = c_rec2100pq;
      return;
    }
    if (tonemap_mode == kToneMapNativeHLG) {
      // For Native HLG, just write the value and return.
      vec3 c_rec2100hlg = hlgOetf(hlgRefOotfInv(c));
      gl_FragColor.rgb = c_rec2100hlg;
      return;
    }

    c = toneMapRec2100NitsToRec2020Linear(c);

    // Convert from rec2020 to P3.
    c = xyzd50_to_p3 * rec2020_to_xyzd50 * c;

    // Convert to sRGB-encoded.
    c = linearToSrgb(c);

    gl_FragColor.rgb = c;
  }`;

let compileShader = function(gl, vertex_source, fragment_source) {
  let vertex_shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertex_shader, vertex_source);
  gl.compileShader(vertex_shader);
  if (!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(vertex_shader));
     
  let fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragment_shader, fragment_source); 
  gl.compileShader(fragment_shader);
  if (!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(fragment_shader));
  
  let program = gl.createProgram();
  gl.attachShader(program, vertex_shader);
  gl.attachShader(program, fragment_shader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    throw new Error(gl.getProgramInfoLog(program));

  return program;
}

let createTexture = function(image, w = 0, h = 0) {
  texture = gl.createTexture();
  if (w == 0) {
    texture_w = image.width;
    texture_h = image.height;
  } else {
    texture_w = w;
    texture_h = h;
  }

  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, texture_w, texture_h, 0, gl.RGBA, gl.FLOAT, image);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.bindTexture(gl.TEXTURE_2D, null);

  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
    texture_pixels = new Float32Array(texture_w * texture_h * 4);
    gl.readPixels(0, 0, texture_w, texture_h, gl.RGBA, gl.FLOAT, texture_pixels);
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(fb);
}

let computeImageMaxRGB = function() {
  let image_max_rgb = 0;
  let image_max_Y = 0;
  for (let x = 0; x < texture_w; ++x) {
    for (let y = 0; y < texture_h; ++y) {
      const offset = 4*(x + y*texture_w);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+0]);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+1]);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+2]);
      let Y = 0.2627 * texture_pixels[offset+0] +
              0.6780 * texture_pixels[offset+1] +
              0.0593 * texture_pixels[offset+2];
      image_max_Y = Math.max(image_max_Y, Y);
    }
  }
  const image_max_nits_Y   = pqSignalToNits(image_max_Y).toFixed();
  const image_max_nits_rgb = pqSignalToNits(image_max_rgb).toFixed();
  ImageMax.innerHTML =
      'Max RGB: ' + image_max_rgb.toFixed(2) + ' (' + image_max_nits_rgb + ' nits)<br>' +
      'Max Y: '   + image_max_Y.toFixed(2)   + ' (' + image_max_nits_Y   + ' nits)';

  if (SignalTransfer.value == 'pq') {
    CLLIMaxNits.value = image_max_nits_Y;
  }
  if (SignalTransfer.value == 'hlg') {
    CLLIMaxNits.value = 1000;
  }
  if (SignalTransfer.value == 'srgb') {
    CLLIMaxNits.value = 203;
  }
}

let draw = function() {
  gl.useProgram(program);

  // Draw using that program.
  let vertices = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

  let indices = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);

  let positionLocation = gl.getAttribLocation(program, 'position');
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  }

  gl.uniform1f(gl.getUniformLocation(program, 'ndwl_white_nits'), NDWLWhiteNits.value);
  gl.uniform1f(gl.getUniformLocation(program, 'clli_max_nits'), CLLIMaxNits.value);
  gl.uniform1f(gl.getUniformLocation(program, 'hlg_ootf_gamma'), hlg_ootf_gamma);

  gl.uniform1i(gl.getUniformLocation(program, 'tonemap_weight_before'), ToneMapCurveBefore.checked);
  gl.uniform1f(gl.getUniformLocation(program, 'tonemap_weight_maxRGB'), ToneMapCurveMaxRGB.value);
  gl.uniform1f(gl.getUniformLocation(program, 'tonemap_weight_RpGpBp'), ToneMapCurveRpGpBp.value);
  gl.uniform1f(gl.getUniformLocation(program, 'tonemap_weight_YRGB'),   ToneMapCurveYRGB.value);

  let desc = '';
  let use_tonemap_curve = false;
  switch(ToneMap.value) {
    case 'None':
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapNone);
      break;
    case 'NativePQ':
      desc == 'native-pq';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapNativePQ);
      break;
    case 'NativeHLG':
      desc == 'native-hlg';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapNativeHLG);
      break;
    case 'Clamp':
      desc = 'clamp';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapClamp);
      break;
    case 'Reinhard':
      use_tonemap_curve = true;
      desc = 'reinhard';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapReinhard);
      break;
    case 'BT2408':
      desc = 'bt2408';
      use_tonemap_curve = true;
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapBT2408);
      break;
    case 'BT2446A':
      use_tonemap_curve = true;
      desc = 'bt2446a';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapBT2446A_redo);
      break;
    case 'BT2446C':
      use_tonemap_curve = true;
      desc = 'bt2446c';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapBT2446C);
      break;
    case 'BT2100HLG':
      desc = 'bt2100_gamma' + hlg_ootf_gamma.toFixed(2);
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapBT2100HLG);
      break;
    case 'HLGAs22':
      desc = 'hgl_as_g22';
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), kToneMapHLGAs22);
      break;
    default:
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_mode'), -1);
      break;
  }

  ParamsToneMapCurve.hidden = !use_tonemap_curve;
  ParamsBT2100HLG.hidden = (ToneMap.value != 'BT2100HLG');

  switch (ToneMap.value) {
    case 'NativePQ':
      gl.drawingBufferColorSpace = 'rec2100-pq';
      canvas.configureHighDynamicRange({
          smpteSt2086Metadata:{
              redPrimaryX:0.708,
              redPrimaryY:0.292,
              greenPrimaryX:0.170,
              greenPrimaryY:0.797,
              bluePrimaryX:0.131,
              bluePrimaryY:0.046,
              whitePointX:0.3127,
              whitePointY:0.3290,
              minimumLuminance:1,
              maximumLuminance:CLLIMaxNits.value,
          }});
      break;

    case 'NativeHLG':
      gl.drawingBufferColorSpace = 'rec2100-hlg';
      canvas.configureHighDynamicRange({});
      break;

    default:
      gl.drawingBufferColorSpace = 'display-p3';
      if (`configureHighDynamicRange` in canvas) {
        if (true || FinalGamutMap.value == 'None') {
          canvas.configureHighDynamicRange({ mode:'extended' });
        } else {
          canvas.configureHighDynamicRange({});
        }
      }
      break;
  }

  let gamutMapToConst = function(value) {
    switch (value) {
      case 'None':
        return kGamutMapNone;
      case 'Mark':
        return kGamutMapMark;
      case 'Clamp':
        return kGamutMapClamp;
      case 'ScaleUV':
        return kGamutMapScaleUV;
      case 'ScaleRGB':
        return kGamutMapScaleRGB;
      case 'RGB-L2':
        return kGamutMapL2RGB;
      case 'OkLabConstantHue':
        return kGamutMapOkLabConstantH;
      default:
        console.log('Bug in gamut mapping selector');
    }
  }

  let gamut_map_desc = '';
  gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), gamutMapToConst(GamutMap.value));
  gl.uniform1i(gl.getUniformLocation(program, 'final_gamut_mode'), gamutMapToConst(FinalGamutMap.value));

  switch (FinalGamut.value) {
    case 'srgb':
      gl.uniform1i(gl.getUniformLocation(program, 'final_gamut'), kGamutSRGB);
      break;
    case 'p3':
      gl.uniform1i(gl.getUniformLocation(program, 'final_gamut'), kGamutP3);
      break;
    case 'rec2020':
      gl.uniform1i(gl.getUniformLocation(program, 'final_gamut'), kGamutRec2020);
      break;
  }

  switch (SignalTransfer.value) {
    case 'srgb':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_transfer'), kTransferSRGB);
      break;
    case 'pq':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_transfer'), kTransferPQ);
      break;
    case 'hlg':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_transfer'), kTransferHLG);
      break;
    case 'pq-g':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_transfer'), kTransferPQ_G);
      break;
  }

  switch (SignalPrimaries.value) {
    case 'srgb':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_primaries'), kGamutSRGB);
      break;
    case 'p3':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_primaries'), kGamutP3);
      break;
    case 'rec2020':
      gl.uniform1i(gl.getUniformLocation(program, 'signal_primaries'), kGamutRec2020);
      break;
  }

  // gl.uniform1i(gl.getUniformLocation(program, 'use_bgr'), CheckboxBGR.checked);
  gl.uniform1i(gl.getUniformLocation(program, 'use_bgr'), 0);

  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

  if (save_requested) {
    save_requested = false;
    let mime_type = "image/jpeg";
    let download_link = document.createElement('a');
    let data_url = canvas.toDataURL(mime_type);

    download_link.download = filename + '-' + desc + '.png';
    download_link.href = data_url;
    download_link.dataset.downloadurl = [mime_type, download_link.download, download_link.href].join(':');

    document.body.appendChild(download_link);
    download_link.click();
    document.body.removeChild(download_link);
  }
}

let initializeGL = function() {
  canvas = document.getElementById('Canvas');

  gl = canvas.getContext('webgl2');
  gl.getExtension('EXT_color_buffer_half_float');
  gl.getExtension('EXT_color_buffer_float');


  let warningsText = '';
  if (!(`drawingBufferColorSpace` in gl)) {
    warningsText += '<br>REQUIRED WebGL API not found (drawingBufferColorSpace)!'
  }

  if (`drawingBufferStorage` in gl) {
    gl.drawingBufferStorage(gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
  } else {
    warningsText += '<br>Experimental WebGL API not found (drawingBufferStorage)!'
  }
  if (!(`configureHighDynamicRange` in canvas)) {
    warningsText += '<br>Experimental HDR Canvas API not found (configureHighDyanmicRange)!'
  }

  if (warningsText != '') {
    warningsText = 'Experimental features missing: Enable "Experimental Web Platform Features" in chrome://flags' + warningsText;

    Warnings.hidden = false;
    Warnings.style = 'color:#BC0000;';
    Warnings.innerHTML = '<strong>' + warningsText + '</strong>';
  }

  program = compileShader(gl, vs, fs);
}

let resizeCanvasStyle = function() {
  let full_height = window.innerHeight;
  let header_bottom = Header.getBoundingClientRect().bottom;
  let max_height = Math.max(full_height - header_bottom - 40, 100);
  console.log();
  Canvas.style = 'max-width:95%; max-height:' + max_height + 'px;';
}

let drawImage = function(image, w = 0, h = 0) {
  createTexture(image, w, h);
  computeImageMaxRGB();

  viewport_w = texture_w;
  viewport_h = texture_h;
  canvas.width = viewport_w;
  canvas.height = viewport_h;
  resizeCanvasStyle();
  gl.viewport(0, 0, viewport_w, viewport_h);
  draw();
}

let loadImage = function(url) {
  texture = null;

  if (0) {
    const kGridSize = 33;
    texture_w = kGridSize * kGridSize;
    texture_h = kGridSize;

    let data = new Float32Array(4 * kGridSize * kGridSize * kGridSize);
    let index = 0;
    for (let r = 0; r < kGridSize; ++r) {
      for (let g = 0; g < kGridSize; ++g) {
        for (let b = 0; b < kGridSize; ++b) {
          data[index + 0] = r / (kGridSize - 1);
          data[index + 1] = g / (kGridSize - 1);
          data[index + 2] = b / (kGridSize - 1);
          data[index + 3] = 1.0;
          index += 4;
        }
      }
    }
    drawImage(data, kGridSize * kGridSize, kGridSize);
    return;
  }

  let image = new Image();
  image.onload = function() {
    createImageBitmap(image, {colorSpaceConversion:"none"}).then((image) => {
      onChange();
      drawImage(image);
    });
/*
    onChange();
    drawImage(image);
*/
  }
  image.onerror  = function() {
    // The video path is SUPER buggy.
    console.log('Failed to create image... trying as a video?');

    let video = Vid;
    if (`requestVideoFrameCallback` in video) {
      let cb = function(now, metadata) {
        video.hidden = false;
        if (1) {
          drawImage(video, metadata.width, metadata.height);
        } else {
          createImageBitmap(video, {colorSpaceConversion:"none"}).then((image) => {
            onChange();
            drawImage(image);
          });
        }
        video.pause();
        video.requestVideoFrameCallback(cb);
      }
      video.requestVideoFrameCallback(cb);
    } else {
      let poll_for_frame = function() {
        createImageBitmap(video, {colorSpaceConversion:"none"}).then((image) => {
          console.log('Got a video frame!');
          onChange();
          drawImage(image);
        }).catch((err) => {
          console.log('Polling for frame ... not ready ...');
          window.requestAnimationFrame(poll_for_frame);
        })
      }
      window.requestAnimationFrame(poll_for_frame);
    }
    video.src = url;
    video.play();
  }
  image.src = url;
  Vid.hidden = true;
}

let onChange = function() {
  let recomputeHlgOotfGamma = function() {
    if (RadioHLG_OOTF_f2.checked) {
      hlg_ootf_gamma = 1.2 * Math.pow(1.111, Math.log(HLG_Lw_Nits.value / 1000.0) / Math.log(2.0));
    }
    if (RadioHLG_OOTF_5f.checked) {
      hlg_ootf_gamma = 1.2 + 0.42 * Math.log(HLG_Lw_Nits.value / 1000.0) / Math.log(10.0);
    }
    HLG_OOTF_Gamma.innerHTML = 'ITU-R BT.2100<br>HLG Gamma: ' + hlg_ootf_gamma.toFixed(4);
  }
  recomputeHlgOotfGamma();

  if (SignalTransfer.value == 'hlg') {
    CLLIMaxNits.value = 1000;
  }
  if (SignalTransfer.value == 'srgb') {
    CLLIMaxNits.value = 203;
  }

  draw();
}

let onToneMapChange = function() {
  onChange();
}

function allowDrop(ev) {
  ev.preventDefault();
}

function onFileList(files) {
  event.preventDefault();
  console.log(files);
  let image_file = null;
  for (const file of files) {
    filename = file.name.split('.').slice(0, -1).join('.');
    console.log(filename);
    image_file = file;
  }

  let reader = new FileReader();
  reader.onloadend = function() {
    let url = reader.result;
    loadImage(url);
  }
  reader.readAsDataURL(image_file)
}

function main() {
  initializeGL();

  let saveCanvas = function() {
    save_requested = true;
    draw();
  }
  ButtonSave.addEventListener('click', saveCanvas);

  ButtonPresetHDR.addEventListener('click', function() {
    restoreSettings({
        'ToneMap':'None',
        'GamutMap':'None',
        'FinalGamutMap':'None',
        'FinalGamut':'rec2020'})});

  // Chromium.
  ButtonPresetReinhardMaxRGB.addEventListener('click', function() {
    restoreSettings({
        'ToneMap':'Reinhard',
        'ToneMapCurveBefore':true,
        'ToneMapCurveMaxRGB':1.0,
        'ToneMapCurveRpGpBp':0.0,
        'ToneMapCurveYRGB':0.0,
        'GamutMap':'Clamp',
        'FinalGamutMap':'None',
        'FinalGamut':'rec2020'})});

  // Eric Chan suggestion.
  ButtonPresetReinhard6040PostMix.addEventListener('click', function() {
    restoreSettings({
        'ToneMap':'Reinhard',
        'ToneMapCurveBefore':false,
        'ToneMapCurveMaxRGB':0.6,
        'ToneMapCurveRpGpBp':0.4,
        'ToneMapCurveYRGB':0.0,
        'GamutMap':'Clamp',
        'FinalGamutMap':'None',
        'FinalGamut':'rec2020'})});

  // BT.2408 cause it deserves consideration (grumble).
  ButtonPresetReinhard5050PreMix.addEventListener('click', function() {
    restoreSettings({
        'ToneMap':'Reinhard',
        'ToneMapCurveBefore':true,
        'ToneMapCurveMaxRGB':0.5,
        'ToneMapCurveRpGpBp':0.5,
        'ToneMapCurveYRGB':0.0,
        'GamutMap':'Clamp',
        'FinalGamutMap':'None',
        'FinalGamut':'rec2020'})});

  let restoreSettings = function(settings) {
    for (const [key, value] of Object.entries(settings)) {
      let e = document.getElementById(key);
      if (`value` in e) {
        e.value = value;
      }
      if (`checked` in e) {
        e.checked = value;
      }
    }
    draw();
  }
  let saveSettings = function() {
    return {
      'ToneMap': ToneMap.value,
      'ToneMapCurveBefore':ToneMapCurveBefore.checked,
      'ToneMapCurveMaxRGB':ToneMapCurveMaxRGB.value,
      'ToneMapCurveRpGpBp':ToneMapCurveRpGpBp.value,
      'ToneMapCurveYRGB':ToneMapCurveYRGB.value,
      'GamutMap': GamutMap.value,
      'FinalGamutMap': FinalGamutMap.value,
      'FinalGamut': FinalGamut.value,
      'HLG_Lw_Nits': HLG_Lw_Nits.value,
    };
  }


  ButtonPresetSave1.addEventListener('click', function() {
    saved_settings1 = saveSettings();
    ButtonPresetRestore1.disabled = false;
  });
  ButtonPresetRestore1.addEventListener('click', function() {
    restoreSettings(saved_settings1);
  });

  ButtonPresetSave2.addEventListener('click', function() {
    saved_settings2 = saveSettings();
    ButtonPresetRestore2.disabled = false;
  });
  ButtonPresetRestore2.addEventListener('click', function() {
    restoreSettings(saved_settings2);
  });

  CLLIMaxNits.addEventListener('input', function (evt) {
    draw();
  });
  NDWLWhiteNits.addEventListener('input', function (evt) {
    draw();
  });

  HLG_Lw_Nits.addEventListener('input', function (evt) {
    draw();
  });

  UploadButton.addEventListener('change', function(e) {
    onFileList(UploadButton.files);
  });
  UploadButtonFake.addEventListener('click', function() {
    UploadButton.click();
  });

  DropArea.addEventListener('drop', function (e) {
    e.preventDefault();
    onFileList(e.dataTransfer.files);
  });
  DropArea.addEventListener('dragover', function (e) {
    e.preventDefault();
  });

  window.onresize = function(event) {
    resizeCanvasStyle();
  };

  loadImage('staircase-pq.avif');
}
</script>
</head>
<body onload='main()'>

<div id='Header'>

<p id='Warnings' hidden=true></p>

<table style="margin-left: auto; margin-right: auto;">
  <tr>
    <td id="DropArea">
      <p 'text-align:center;'>
      <input  type="file"   id="UploadButton" style="display:none">
      <button type="button" id="UploadButtonFake">Upload Image</button>
      </p>
      <p id="VidContainer"><video style="width:200px;"id='Vid' hidden muted controls></video></p>
      <p id='ImageMax'>Image maximum<br>Pixel value: (undefined)</p>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      <label for="SignalTransfer">Image transfer function:</label>
      <select name="SignalTransfer" id="SignalTransfer" onchange='onChange();'>
        <option value="srgb">sRGB</option>
        <option value="pq" selected>PQ</option>
        <option value="hlg">HLG</option>
      </select>

      <br>

      <label for="SignalPrimaries">Image primaries:</label>
      <select name="SignalPrimaries" id="SignalPrimaries" onchange='onChange();'>
        <option value="srgb">sRGB</option>
        <option value="p3">P3</option>
        <option value="rec2020" selected>ITU-R BT.2020</option>
      </select>

      <br><br>

      <label for="CLLIMaxNits">Image CLLI Max Luminance (nits)</label>
      <input id="CLLIMaxNits" type="number" min="1" max="10000" value="1000"/>

      <br>

      <label for="NDWLWhiteNits">Image NDWL White Luminance (nits)</label>
      <input id="NDWLWhiteNits" type="number" min="1" max="10000" value="203" onchange='onChange();'/>

    <br>

    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      <p><button type="button" id="ButtonSave">Save Canvas</button></p>
    </td>

  </tr>
</table>

<!-- **** Tonemap parameters **** -->
<hr>

<table style="margin-left: auto; margin-right: auto;">
  <tr>
  <td style="text-align:center;">
    <p>Presets:</p>
        <button type="button" id="ButtonPresetHDR">HDR</button>
        <button type="button" id="ButtonPresetReinhardMaxRGB">Reinhard maxRGB</button>
    <br>
        <button type="button" id="ButtonPresetReinhard6040PostMix">Reinhard 60/40 post-mix</button>
        <button type="button" id="ButtonPresetReinhard5050PreMix">Reinhard 50/50 pre-mix</button>
    <br>
        <button type="button" id="ButtonPresetSave1">Save (1)</button>
        <button type="button" id="ButtonPresetRestore1" disabled>Restore (1)</button>
    <br>
        <button type="button" id="ButtonPresetSave2">Save (2)</button>
        <button type="button" id="ButtonPresetRestore2" disabled>Restore (2)</button>
  </td>

  <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>


  <td style="">
    <label for="ToneMap">Tone mapping:</label><br>
    <select name="ToneMap" id="ToneMap" onchange='onChange();'>
      <option value="None">Full HDR</option>
      <option value="NativePQ">Native HDR10 tone mapping (to display)</option>
      <option value="NativeHLG">Native HLG tone mapping (to display)</option>
      <option value="Clamp">Clamp to NDWL</option>
      <option value="Reinhard">Reinhard (map CLLI max to NDWL)</option>
      <option value="BT2408">ITU-R BT.2408 Annex 5 (map CLLI max to NDWL)</option>
      <option value="BT2446A">ITU-R BT.2446 Method A (map CLLI max to NDWL)</option>
      <option value="BT2446C">ITU-R BT.2446 Method C (hard-coded constants)</option>
      <option value="BT2100HLG">HLG rendered using ITU-R BT.2100 (with specified Lw)</option>
      <option value="HLGAs22">HLG reinterpreted as Gamma 2.2</option>
    </select>

  <br><br>

    <label for="GamutMap">Tone mapping gamut map to Rec2020:</label><br>
    <select name="GamutMap" id="GamutMap" onchange='onChange();'>
      <option selected value="None">None (allow out-of-gamut values)</option>
      <option value="Clamp">Clamp RGB to target gamut</option>
      <option value="ScaleRGB">Scale RGB to gamut</option>
      <option value="ScaleUV">Scale chroma (UV) to gamut</option>
      <option value="RGB-L2">Min RGB L2</option>
    </select>


  <br><br>

    <label for="FinalGamut">SDR gamut mapping:</label><br>
    <select name="FinalGamutMap" id="FinalGamutMap" onchange='onChange();'>
      <option selected value="None">None (allow out of gamut values)</option>
      <option value="Mark">Mark out of gamut colors as red</option>
      <option value="Clamp">Clamp</option>
      <option value="ScaleRGB">Scale RGB to gamut</option>
      <option value="ScaleUV">Scale chroma (UV) to gamut</option>
      <option value="RGB-L2">Min RGB L2</option>
      <option value="OkLabConstantHue">OkLab constant hue</option>
    </select>
    <select name="FinalGamut" id="FinalGamut" onchange='onChange();'>
      <option value="srgb">sRGB</option>
      <option value="p3">P3</option>
      <option value="rec2020" selected>ITU-R BT.2020</option>
    </select>
  </td>

  <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

  <td style="width:300px; vertical-align:top;">
    <div id="ParamsToneMapCurve">

    <p>
      <label for="ToneMapCurveBefore">Mix before applying curve</label>
      <input id="ToneMapCurveBefore" type="checkbox" onchange='onChange();'/>
    </p>

    <p>
      <input id="ToneMapCurveMaxRGB" type="number" step="0.01" min="0" max="1" value="0.6" onchange='onChange();'/>
      maxRGB +
      <br>
      <input id="ToneMapCurveRpGpBp" type="number" step="0.01" min="0" max="1" value="0.6" onchange='onChange();'/>
      R'G'B' +
      <br>
      <input id="ToneMapCurveYRGB"   type="number" step="0.01" min="0" max="1" value="0.0" onchange='onChange();'/>
      YRGB
    </p>

    </div>

    <div id="ParamsBT2100HLG">
    <p id="HLG_OOTF_Gamma"> ITU-R BT.2100<br>HLG Gamma: (unknown) </p>
    <table>
      <tr>
        <td>
          <label for="HLG_Lw_Nits">Lw (nits)</label><br>
          <input id="HLG_Lw_Nits" type="number" min="1" max="10000" value="100" onchange='onChange();'/>
        </td>
        <td>
          <input type="radio" id="RadioHLG_OOTF_f2" onchange='onChange();' name="hlg_ootf_gamma" checked="true">
          <label for="RadioHLG_OOTF_f2">Footnote 2</label>
          <br>
          <input type="radio" id="RadioHLG_OOTF_5f" onchange='onChange();' name="hlg_ootf_gamma">
          <label for="RadioHLG_OOTF_5f">Note 5f</label>
        </td>
      </tr>
    </table>
    </div>
  </td>
</tr>
</table>

</div>
<div id='Viewer' style='text-align:center;'>

<p><canvas id='Canvas' width='32' height='32'></canvas></p>

</div>

</body>
</html>
