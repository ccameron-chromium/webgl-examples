<html>
<head>
<style>
#drop-area {
  border: 2px dashed #ccc;
  border-radius: 20px;
  padding: 10px;
}
#drop-area.highlight {
  border-color: purple;
}
</style>
<script>
var canvas;
var gl;
var program;
var filename;

var texture;
var texture_w;
var texture_h;
var texture_pixels;

var hlg_ootf_gamma = 1.2;

var viewport_w;
var viewport_h;
var save_requested = false;

let linearToSrgb = function (x) {
  let a = 1.1371188301409823;
  let c = 12.919999999992248;
  let d = 0.003130800090713953;
  let e = -0.05499994754780801;
  let g = 0.4166666666666667;
  if (x < d)
    return c*x;
  return Math.pow(a*x, g) + e;
}

let pqSignalToNits = function(v) {
  const c1 =  107.0 / 128.0;
  const c2 = 2413.0 / 128.0;
  const c3 = 2392.0 / 128.0;
  const m1 = 1305.0 / 8192.0;
  const m2 = 2523.0 / 32.0;
  const p = Math.pow(Math.min(Math.max(v, 0.0), 1.0), 1.0 / m2);
  return 10000.0 * Math.pow(Math.max(p - c1, 0.0) / (c2 - c3 * p), 1.0 / m1);
}

const vs = `attribute vec2 position;
            varying vec2 texcoord;
            void main() {
              texcoord = vec2(0.5+0.5*position.x, 0.5-0.5*position.y);
              gl_Position = vec4(position, 0.0, 1.0);
            }`;
const fs = `
  precision highp float;
  uniform sampler2D texture;
  uniform float clli_max_nits;
  uniform float ndwl_white_nits;
  uniform float hlg_ootf_gamma;
  uniform int mode;
  uniform int tonemap_scalar_mode;
  uniform int gamut_map_mode;
  uniform int mark_out_of_gamut;
  uniform int transfer;
  uniform int primaries;
  uniform int use_bgr;
  varying vec2 texcoord;

  // Primary conversion matrices.
  mat3 p3_to_xyzd50 = mat3( 0.515102,  0.241182,  -0.00104941,
                            0.291965,  0.692236,   0.0418818,
                            0.157153,  0.0665819,  0.784378);
  mat3 srgb_to_xyzd50 = mat3( 0.43606567, 0.2224884,  0.01391602,
                              0.38514709, 0.71687317, 0.09707642,
                              0.14306641, 0.06060791, 0.71409607);
  mat3 rec2020_to_xyzd50 = mat3( 0.673459,  0.279033,   -0.00193139,
                                 0.165661,  0.675338,    0.0299794,
                                 0.1251,    0.0456288,   0.797162);
  mat3 xyzd50_to_rec2020 = mat3( 1.6472752,  -0.68261762,  0.02966273,
                                -0.39360248,  1.64761778, -0.06291669,
                                -0.23598029,  0.01281627,  1.25339643);
  mat3 xyzd50_to_p3 = mat3( 2.40404516, -0.84222838,  0.04818706,
                           -0.98989869,  1.79885051, -0.09737385,
                           -0.39763172,  0.01604817,  1.27350664);
  mat3 xyzd50_to_srgb = mat3( 3.13411215, -0.97878729,  0.07198304,
                             -1.61739246,  1.91627959, -0.22898585,
                             -0.4906334,   0.03345471,  1.40538513);

  // Y_rec2020 is the luminance vector in rec2020 primaries.
  vec3 rec2020_rgb_to_yuv(vec3 rgb) {
    mat4 rgb_to_yuv = mat4(
        0.262700, -0.139630,  0.500000,  0.0,
        0.678000, -0.360370, -0.459786,  0.0,
        0.059300,  0.500000, -0.040214,  0.0,
        0.000000,  0.500122,  0.500122,  1.0);
    return (rgb_to_yuv * vec4(rgb, 1.0)).rgb;
  }
  vec3 rec2020_yuv_to_rgb(vec3 yuv) {
    mat4 yuv_to_rgb =  mat4(
         1.0,         1.0,         1.0,         0.0,
        -0.00000089, -0.16455278,  1.88139998,  0.0,
         1.47459975, -0.57135301, -0.00000024,  0.0,
        -0.73747933,  0.36804268, -0.9409294,   1.0);
    return (yuv_to_rgb * vec4(yuv, 1.0)).rgb;
  }

  float srgbToLinear(float x) {
    if (x < 0.0)
      return 0.0;
    if (x < 0.04045)
      return x / 12.92;
    return pow((x + 0.055)/1.044, 2.4);
  }
  float linearToSrgb(float x) {
    if (x < 0.003130800090713953)
      return 12.919999999992248*x;
    return pow(1.1371188301409823*x, 0.4166666666666667) - 0.05499994754780801;
  }
  vec3 srgbToLinear(vec3 c) {
    return vec3(srgbToLinear(c.r), srgbToLinear(c.g), srgbToLinear(c.b));
  }
  vec3 linearToSrgb(vec3 c) {
    return vec3(linearToSrgb(c.r), linearToSrgb(c.g), linearToSrgb(c.b));
  }

  float pqSignalToNits(float v) {
    float c1 =  107.0 / 128.0;
    float c2 = 2413.0 / 128.0;
    float c3 = 2392.0 / 128.0;
    float m1 = 1305.0 / 8192.0;
    float m2 = 2523.0 / 32.0;
    float p = pow(clamp(v, 0.0, 1.0), 1.0 / m2);
    return 10000.0 * pow(max(p - c1, 0.0) / (c2 - c3 * p), 1.0 / m1);
  }
  float pqNitsToSignal(float L) {
    float c1 =  107.0 / 128.0;
    float c2 = 2413.0 / 128.0;
    float c3 = 2392.0 / 128.0;
    float m1 = 1305.0 / 8192.0;
    float m2 = 2523.0 / 32.0;
    float v = pow(clamp(L / 10000.0, 0.0, 1.0), m1);
    return pow((c1 + c2 * v) / (1.0 + c3 * v), m2);
  }
  float pqNormalizedSignal(float L, float Lw, float Lb) {
    return (pqNitsToSignal(L)  - pqNitsToSignal(Lb)) /
           (pqNitsToSignal(Lw) - pqNitsToSignal(Lb));
  }

  float hlgOetfInv(float x) {
    const float a = 0.17883277;
    const float b = 1.0 - 4.0*a;
    const float c = 0.5 - a * log(4.0 * a);
    if (x <= 0.5) {
      return pow(x, 2.0) / 3.0;
    } else {
      return (exp((x - c) / a) + b) / 12.0;
    }
  }
  float hlgOetf(float x) {
    const float a = 0.17883277;
    const float b = 1.0 - 4.0*a;
    const float c = 0.5 - a * log(4.0 * a);
    float E = 12.0 * x;
    if (E < 1.0) {
      return 0.5 * sqrt(E);
    }
    return a * log(E - b) + c;
  }

  float toneMapGainChrome(float L, float Lc, float Ld) {
    if (Ld < Lc) {
      float a = Ld / (Lc*Lc);
      float b = 1.0 / Ld;
      return (1.0 + a*L) / (1.0 + b*L);
    }
    return 1.0;
  }

  // Content is in [Lb, Lw]
  // Display is [Lmin, Lmax]
  float toneMapGainBT2408(float L, float Lb, float Lw, float Lmin, float Lmax) {
    if (Lmax >= Lw) {
      return 1.0;
    }
    if (L >= Lw - 0.001) {
      return Lmax / L;
    }

    float Eprime = L;

    float E1 = pqNormalizedSignal(Eprime, Lw, Lb);
    float minLum = pqNormalizedSignal(Lmin, Lw, Lb);
    float maxLum = pqNormalizedSignal(Lmax, Lw, Lb);
    float KS = 1.5 * maxLum - 0.5;
    float b = minLum;

    float E2 = 0.0;
    if (E1 <= KS) {
      return 1.0;
      E2 = E1;
    } else {
      float TB1 = (E1 - KS) / (1.0 - KS);
      float TB2 = TB1 * TB1;
      float TB3 = TB2 * TB1;
      E2 = ( 2.0*TB3 - 3.0*TB2 + 1.0) * KS + \
           (     TB3 - 2.0*TB2 + TB1) * (1.0 - KS) + \
           (-2.0*TB3 + 3.0*TB2      ) * maxLum;
    }
    float E3 = E2 + b*pow(max(1.0 - E2, 0.0), 4.0);
    float E4 = E3 * (pqNitsToSignal(Lw) - pqNitsToSignal(Lb)) + pqNitsToSignal(Lb);
    return pqSignalToNits(E4) / Eprime;
  }

  float toneMapGainBT2446a(float Y_HDR, float L_HDR, float L_SDR) {
    float rho_hdr = 1.0 + 32.0 * pow(L_HDR / 10000.0, 1.0/2.4);
    float rho_sdr = 1.0 + 32.0 * pow(L_SDR / 10000.0, 1.0/2.4);
 
    // Y_HDR is "A normalized full-range linear display-light HDR signal"
    float Yprime = pow(Y_HDR / L_HDR, 1.0/2.4);
 
    float Yp_prime = log(1.0 + (rho_hdr - 1.0) * Yprime) / log(rho_hdr);
    float Yc_prime = 0.0;
    if (Yp_prime < 0.0) {
      Yc_prime = 0.0;
    } else if (Yp_prime < 0.7399) {
      Yc_prime = 1.0770 * Yp_prime;
    } else if (Yp_prime < 0.9909) {
      Yc_prime = -1.1510 * pow(Yp_prime, 2.0) + 2.7811*Yp_prime - 0.6302;
    } else if (Yp_prime <= 1.0) {
      Yc_prime = 0.5 * Yp_prime + 0.5;
    } else {
      Yc_prime = 1.0;
    }
    float Ysdr_prime = (pow(rho_sdr, Yc_prime) - 1.0) / (rho_sdr - 1.0);
 
    // This is not explicitly in the formulation, but I think was intended.
    float Ysdr = pow(Ysdr_prime, 2.4);
    return (Ysdr * L_SDR) / Y_HDR;
  }

  float toneMapGainBT2446c(float Y_hdr) {
      float k1 = 0.83802;
      float k2 = 15.09968;
      float k3 = 0.74204;
      float k4 = 78.99439;
      float HDR_ip = 58.5 / k1;

      float Y_sdr = 0.0;
      if (Y_hdr < HDR_ip) {
        Y_sdr = k1 * Y_hdr;
      } else {
        Y_sdr = k2 * log(Y_hdr / HDR_ip - k3) + k4;
      }
      const float kSdrMax = 120.0;
      if (Y_sdr > kSdrMax) {
        Y_sdr = kSdrMax;
      }
      Y_sdr *= ndwl_white_nits / kSdrMax;
      return Y_sdr / Y_hdr;
  }

  // Intersect the line segment between a and b with the unit cube.
  // Assumes that b is always inside the unit cube.
  vec3 intersectWithUnitCube(vec3 a, vec3 b) {
    float alpha = 1.0;
    for (int i = 0; i < 3; ++i) {
      if (a[i] > 1.0) {
        float alpha_i = (1.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      } else if (a[i] < 0.0) {
        float alpha_i = (0.0 - b[i]) / (a[i] - b[i]);
        alpha = min(alpha, alpha_i);
      }
    }
    alpha = max(alpha, 0.0);
    return alpha * a + (1.0 - alpha) * b;
  }

  vec3 gamutMapClamp(vec3 rgb) {
    return clamp(rgb, 0.0, 1.0);
  }

  vec3 gamutMapScale(vec3 rgb) {
    return intersectWithUnitCube(rgb, vec3(0.0, 0.0, 0.0));
  }

  vec3 gamutMapScaleUV(vec3 rgb) {
    float Y = rec2020_rgb_to_yuv(rgb).r;
    return intersectWithUnitCube(rgb, vec3(Y, Y, Y));
  }

  vec3 mark_out_of_range(vec3 c) {
    float kEpsilon;
    kEpsilon = 0.1;
    if (c.r < -kEpsilon || c.r > 1.0 + kEpsilon ||
        c.g < -kEpsilon || c.g > 1.0 + kEpsilon ||
        c.b < -kEpsilon || c.b > 1.0 + kEpsilon) {
      return vec3(1.0, 0.0, 0.0);
    }
    kEpsilon = 0.01;
    if (c.r < -kEpsilon || c.r > 1.0 + kEpsilon ||
        c.g < -kEpsilon || c.g > 1.0 + kEpsilon ||
        c.b < -kEpsilon || c.b > 1.0 + kEpsilon) {
      return vec3(1.0, 1.0, 0.0);
    }
    kEpsilon = 0.00001;
    if (c.r < -kEpsilon || c.r > 1.0 + kEpsilon ||
        c.g < -kEpsilon || c.g > 1.0 + kEpsilon ||
        c.b < -kEpsilon || c.b > 1.0 + kEpsilon) {
      return vec3(0.0, 1.0, 0.0);
    }
    return c;
  }

  vec3 hlgRefOotf(vec3 c) {
    float Y = rec2020_rgb_to_yuv(c).r;
    c *= pow(Y, 0.2);
    c *= 1000.0;
    return c;
  }
  vec3 hlgRefOotfInv(vec3 c) {
    c /= 1000.0;
    c = clamp(c, 0.0, 1.0);
    c *= pow(rec2020_rgb_to_yuv(c).r, -0.2 / 1.2);
    return c;
  }

  // Find alpha in [0, 1] that minimizes |c0 - (alpha*c1 + (1-alpha)*c2)|
  vec3 nearestPointOnSegment(vec3 c0, vec3 c1, vec3 c2) {
    // let u = c2 - c1
    // let v = c0 - c1
    // minimize dist2(c0, c1 + alpha*(c2 - c1)) =
    //          dist2(c0, c1 + alpha*u) =
    //          dot(alpha*u - v, alpha*u - v) =
    //          alpha^2 * dot(u, u) - alpha*2*dot(u, v) + dot(v, v)
    // this is minimized at alpha = dot(u, v) / dot(u, u)
    vec3 u = c2 - c1;
    vec3 v = c0 - c1;
    float a = dot(u, u);
    float b = 2.0 * dot(u, v);
    if (a <= 0.0) {
      return c0;
    }
    float alpha = clamp(dot(u, v) / a, 0.0, 1.0);
    return (1.0 - alpha) * c1 + alpha * c2;
  }

  void main() {
    vec3 c = texture2D(texture, texcoord).rgb;
    if (use_bgr == 1) {
      c = c.bgr;
    }
    gl_FragColor.a = 1.0;

    // Convert to linear.
    if (transfer == 0) {
      c = vec3(pqSignalToNits(c.r), pqSignalToNits(c.g), pqSignalToNits(c.b));
    }
    if (transfer == 1) {
      c = vec3(hlgOetfInv(c.r), hlgOetfInv(c.g), hlgOetfInv(c.b));
    }

    // Convert from image primaries to rec2020 primaries.
    if (primaries == 0) {
      c = xyzd50_to_rec2020 * srgb_to_xyzd50 * c;
    }
    if (primaries == 1) {
      c = xyzd50_to_rec2020 * p3_to_xyzd50 * c;
    }

    // Apply the HLG OOTF (and scale up).
    if (transfer == 1) {
      c = hlgRefOotf(c);
    }

    // For Native PQ mode, convert nits back to singal.
    if (mode == -1) {
      c = vec3(pqNitsToSignal(c.r), pqNitsToSignal(c.g), pqNitsToSignal(c.b));
      gl_FragColor.rgb = c;
      return;
    }

    // For Native HLG mode, convert nits back to signal.
    if (mode == -2) {
      c = hlgRefOotfInv(c);
      c = vec3(hlgOetf(c.r), hlgOetf(c.g), hlgOetf(c.b));
      gl_FragColor.rgb = c;
      return;
    }

    if (mode == 6) {
      // If the mode is ITU-R BT.2100, just apply the custom OOTF gamma.

      // Convert back to linear [0, 1] before the OOTF.
      c = hlgRefOotfInv(c);

      // Apply the specified gamma.
      float Y = rec2020_rgb_to_yuv(c).r;
      c *= pow(Y, hlg_ootf_gamma - 1.0);

    } else {
      // For all other modes, we apply tonemapping to nits.

      // Compute the tonemapping gain.
      vec3 gain = vec3(1.0, 1.0, 1.0);
      {
        // Compute the tonemapping function input.
        vec3 tonemap_input = vec3(0.0, 0.0, 0.0);
        if (tonemap_scalar_mode == 0) {
          // maxRGB
          tonemap_input = vec3(max(max(c.r, c.g), c.b));
        }
        if (tonemap_scalar_mode == 1) {
          // YRGB
          tonemap_input = vec3(rec2020_rgb_to_yuv(c).r);
        }
        if (tonemap_scalar_mode == 2) {
          // R'G'B'
          tonemap_input = c;
        }

        // Compute the tonemapping function's gain for each channel.
        if (mode == 2) {
          // Reinhard.
          gain = vec3(
              toneMapGainChrome(tonemap_input.r, clli_max_nits, ndwl_white_nits),
              toneMapGainChrome(tonemap_input.g, clli_max_nits, ndwl_white_nits),
              toneMapGainChrome(tonemap_input.b, clli_max_nits, ndwl_white_nits));
        }
        if (mode == 3) {
          // ITU-R BT.2408.
          gain = vec3(
              toneMapGainBT2408(tonemap_input.r, 0.0, clli_max_nits, 0.0, ndwl_white_nits),
              toneMapGainBT2408(tonemap_input.g, 0.0, clli_max_nits, 0.0, ndwl_white_nits),
              toneMapGainBT2408(tonemap_input.b, 0.0, clli_max_nits, 0.0, ndwl_white_nits));
        }
        if (mode == 4) {
          // ITU-R BT.2446 Method A.
          gain = vec3(toneMapGainBT2446a(tonemap_input.r, clli_max_nits, ndwl_white_nits),
                      toneMapGainBT2446a(tonemap_input.g, clli_max_nits, ndwl_white_nits),
                      toneMapGainBT2446a(tonemap_input.b, clli_max_nits, ndwl_white_nits));
        }
        if (mode == 5) {
          // ITU-R BT.2446 Method C.
          gain = vec3(toneMapGainBT2446c(tonemap_input.r),
                      toneMapGainBT2446c(tonemap_input.g),
                      toneMapGainBT2446c(tonemap_input.b));
        }
      }

      // Apply the tonemapping gain.
      c *= gain;

      // Scale NDWL nits down to 1.0
      c /= ndwl_white_nits;
    }

    // Gamut map.
    if (mode != 1) {
      if (gamut_map_mode == 1) {
        c = gamutMapClamp(c);
      }
      if (gamut_map_mode == 2) {
        c = gamutMapScaleUV(c);
      }
      if (gamut_map_mode == 3) {
        c = gamutMapScale(c);
      }
      if (gamut_map_mode == 4) {
        // This is finding the nearest L2 point in RGB space that is in the
        // plane through R=G=B and the color c itself. I should look into adding
        // some sort of weighting matrix nearestPointOnSegment, so that one can
        // use that to trade off between chrome and luma changes (I guess).
        float maxRGB = max(max(c.r, c.g), c.b);
        if (maxRGB > 1.0) {
          c = nearestPointOnSegment(c, c / maxRGB, vec3(1.0, 1.0, 1.0));
        }
      }
    }

    if (mark_out_of_gamut == 1) {
      c = mark_out_of_range(c);
    }

    // Convert from rec2020 to P3.
    c = xyzd50_to_p3 * rec2020_to_xyzd50 * c;

    // Convert to sRGB-encoded.
    c = linearToSrgb(c);

    gl_FragColor.rgb = c;
  }`;

let compileShader = function(gl, vertex_source, fragment_source) {
  let vertex_shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(vertex_shader, vertex_source);
  gl.compileShader(vertex_shader);
  if (!gl.getShaderParameter(vertex_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(vertex_shader));
     
  let fragment_shader = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(fragment_shader, fragment_source); 
  gl.compileShader(fragment_shader);
  if (!gl.getShaderParameter(fragment_shader, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(fragment_shader));
  
  let program = gl.createProgram();
  gl.attachShader(program, vertex_shader);
  gl.attachShader(program, fragment_shader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS))
    throw new Error(gl.getProgramInfoLog(program));

  return program;
}

let createTexture = function(image) {
  texture = gl.createTexture();
  texture_w = image.width;
  texture_h = image.height;

  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA16F, texture_w, texture_h, 0, gl.RGBA, gl.FLOAT, image);
  gl.generateMipmap(gl.TEXTURE_2D);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.bindTexture(gl.TEXTURE_2D, null);

  var fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
  if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) == gl.FRAMEBUFFER_COMPLETE) {
    texture_pixels = new Float32Array(texture_w * texture_h * 4);
    gl.readPixels(0, 0, texture_w, texture_h, gl.RGBA, gl.FLOAT, texture_pixels);
  }
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.deleteFramebuffer(fb);
}

let computeImageMaxRGB = function() {
  let image_max_rgb = 0;
  let image_max_Y = 0;
  for (let x = 0; x < texture_w; ++x) {
    for (let y = 0; y < texture_h; ++y) {
      const offset = 4*(x + y*texture_w);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+0]);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+1]);
      image_max_rgb = Math.max(image_max_rgb, texture_pixels[offset+2]);
      let Y = 0.2627 * texture_pixels[offset+0] +
              0.6780 * texture_pixels[offset+1] +
              0.0593 * texture_pixels[offset+2];
      image_max_Y = Math.max(image_max_Y, Y);
    }
  }
  const image_max_nits_Y   = pqSignalToNits(image_max_Y).toFixed();
  const image_max_nits_rgb = pqSignalToNits(image_max_rgb).toFixed();
  ImageMax.innerHTML =
      'Max RGB: ' + image_max_rgb.toFixed(2) + ' (' + image_max_nits_rgb + ' nits)<br>' +
      'Max Y: '   + image_max_Y.toFixed(2)   + ' (' + image_max_nits_Y   + ' nits)';

  CLLIMaxNits.value = image_max_nits_Y;
}

let draw = function() {
  gl.useProgram(program);

  // Draw using that program.
  let vertices = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vertices);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, 1,1, -1,1]), gl.STATIC_DRAW);

  let indices = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0,1,2, 0,2,3]), gl.STATIC_DRAW);

  let positionLocation = gl.getAttribLocation(program, 'position');
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionLocation);

  {
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.uniform1i(gl.getUniformLocation(program, 'texture'), 0);
  }

  gl.uniform1f(gl.getUniformLocation(program, 'ndwl_white_nits'), NDWLWhiteNits.value);
  gl.uniform1f(gl.getUniformLocation(program, 'clli_max_nits'), CLLIMaxNits.value);
  gl.uniform1f(gl.getUniformLocation(program, 'hlg_ootf_gamma'), hlg_ootf_gamma);

  let mode = '';
  let use_tonemap = false;
  if (RadioClamp.checked) {
    mode = 'clamp';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 0);
  }
  if (RadioFullHDR.checked) {
    mode = 'hdr';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 1);
  }
  if (RadioReinhard.checked) {
    mode = 'reinhard';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 2);
    use_tonemap = true;
  }
  if (RadioBT2408.checked) {
    mode = 'bt2408';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 3);
    use_tonemap = true;
  }
  if (RadioBT2446A.checked) {
    mode = 'bt2446a';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 4);
    use_tonemap = true;
  }
  if (RadioBT2446C.checked) {
    mode = 'bt2446c';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 5);
    use_tonemap = true;
  }
  if (RadioBT2100.checked) {
    mode = 'bt2100_gamma' + hlg_ootf_gamma.toFixed(2);
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), 6);
  }
  if (RadioNativePQ.checked) {
    mode = 'native-pq';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), -1);

    gl.drawingBufferColorSpace = 'rec2100-pq';
    canvas.configureHighDynamicRange({
        smpteSt2086Metadata:{
            redPrimaryX:0.708,
            redPrimaryY:0.292,
            greenPrimaryX:0.170,
            greenPrimaryY:0.797,
            bluePrimaryX:0.131,
            bluePrimaryY:0.046,
            whitePointX:0.3127,
            whitePointY:0.3290,
            minimumLuminance:1,
            maximumLuminance:CLLIMaxNits.value,
        }});
  } else if (RadioNativeHLG.checked) {
    mode = 'native-hlg';
    gl.uniform1i(gl.getUniformLocation(program, 'mode'), -2);

    gl.drawingBufferColorSpace = 'rec2100-hlg';
    canvas.configureHighDynamicRange({});
  } else {
    gl.drawingBufferColorSpace = 'display-p3';
    if (`configureHighDynamicRange` in canvas) {
      canvas.configureHighDynamicRange({ mode:'extended' });
    }
  }

  if (use_tonemap) {
    if (RadioMaxRGB.checked) {
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_scalar_mode'), 0);
      mode += '-max_rgb'
    }
    if (RadioYRGB.checked) {
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_scalar_mode'), 1);
      mode += '-y_rgb'
    }
    if (RadioRpGpBp.checked) {
      gl.uniform1i(gl.getUniformLocation(program, 'tonemap_scalar_mode'), 2);
      mode += '-rpgpbp'
    }
  } else {
    gl.uniform1i(gl.getUniformLocation(program, 'tonemap_scalar_mode'), -1);
  }

  
  let gamut_map_mode = '';
  if (RadioGamutNone.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 0);
  }
  if (RadioGamutClamp.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 1);
    gamut_map_mode = '-clamp_rgb';
  }
  if (RadioGamutScaleUV.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 2);
    gamut_map_mode = '-scale_uv';
  }
  if (RadioGamutScaleRGB.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 3);
    gamut_map_mode = '-scale_rgb';
  }
  if (RadioGamutRGB_L2.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 4);
    gamut_map_mode = '-rgbL2';
  }
  if (RadioGamutYUV_L2.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'gamut_map_mode'), 5);
    gamut_map_mode = '-yuvL2';
  }

  gl.uniform1i(gl.getUniformLocation(program, 'mark_out_of_gamut'), RadioGamutMark.checked);


  if (RadioPQ.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'transfer'), 0);
  }
  if (RadioHLG.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'transfer'), 1);
  }

  if (RadioSRGB.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'primaries'), 0);
  }
  if (RadioP3.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'primaries'), 1);
  }
  if (RadioBT2020.checked) {
    gl.uniform1i(gl.getUniformLocation(program, 'primaries'), 2);
  }

  gl.uniform1i(gl.getUniformLocation(program, 'use_bgr'), CheckboxBGR.checked);

  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);

  if (save_requested) {
    save_requested = false;
    let mime_type = "image/jpeg";
    let download_link = document.createElement('a');
    let data_url = canvas.toDataURL(mime_type);

    download_link.download = filename + '-' + mode + gamut_map_mode + '.png';
    download_link.href = data_url;
    download_link.dataset.downloadurl = [mime_type, download_link.download, download_link.href].join(':');

    document.body.appendChild(download_link);
    download_link.click();
    document.body.removeChild(download_link);
  }
}

let initializeGL = function() {
  canvas = document.getElementById('Canvas');

  gl = canvas.getContext('webgl2');
  gl.getExtension('EXT_color_buffer_half_float');

  if (`drawingBufferStorage` in gl) {
    gl.drawingBufferStorage(gl.RGBA16F, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }

  program = compileShader(gl, vs, fs);
}

let drawImage = function(image) {
  createTexture(image);
  computeImageMaxRGB();

  viewport_w = image.width;
  viewport_h = image.height;
  canvas.width = viewport_w;
  canvas.height = viewport_h;
  canvas.style = 'max-width:100%; max-height:85vh;';
  gl.viewport(0, 0, viewport_w, viewport_h);
  draw();
}

let loadImage = function(url) {
  texture = null;

  let image = new Image();
  image.onload = function() {
    createImageBitmap(image, {colorSpaceConversion:"none"}).then((image) => {
      onChange();
      drawImage(image);
    });
/*
    onChange();
    drawImage(image);
*/
  }
  image.src = url;
}

let onChange = function() {
  let recomputeHlgOotfGamma = function() {
    if (RadioHLG_OOTF_f2.checked) {
      hlg_ootf_gamma = 1.2 * Math.pow(1.111, Math.log(HLG_Lw_Nits.value / 1000.0) / Math.log(2.0));
    }
    if (RadioHLG_OOTF_5f.checked) {
      hlg_ootf_gamma = 1.2 + 0.42 * Math.log(HLG_Lw_Nits.value / 1000.0) / Math.log(10.0);
    }
    HLG_OOTF_Gamma.innerHTML = 'ITU-R BT.2100<br>HLG Gamma: ' + hlg_ootf_gamma.toFixed(4);
  }
  recomputeHlgOotfGamma();

  if (RadioHLG.checked) {
    CLLIMaxNits.value = 1000;
  }
  if (RadioPQ.checked) {
  }

  draw();
}

let onToneMapChange = function() {
  onChange();
}

function allowDrop(ev) {
  ev.preventDefault();
}

function onDrop(event) {
  event.preventDefault();
  console.log(event.dataTransfer.files);
  let image_file = null;
  for (const file of event.dataTransfer.files) {
    filename = file.name.split('.').slice(0, -1).join('.');
    console.log(filename);
    image_file = file;
  }

  let reader = new FileReader();
  reader.onloadend = function() {
    let url = reader.result;
    loadImage(url);
  }
  reader.readAsDataURL(image_file)
}


function main() {
  initializeGL();

  let saveCanvas = function() {
    save_requested = true;
    draw();
  }

  ButtonSave.addEventListener('click', saveCanvas);
  CLLIMaxNits.addEventListener('input', function (evt) {
    draw();
  });
  NDWLWhiteNits.addEventListener('input', function (evt) {
    draw();
  });

  HLG_Lw_Nits.addEventListener('input', function (evt) {
    draw();
  });

  loadImage('staircase-pq.avif');
  // loadImage('tonemap/image_01.png');
}
</script>
</head>
<body onload='main()'>

<table style="margin-left: auto; margin-right: auto;">
  <tr>
    <td>
      <div id="drop-area" ondrop="onDrop(event)" ondragover="allowDrop(event)">
      Drop HDR image here.
      </div>
      <p id='ImageMax'>Image maximum<br>Pixel value: (undefined)</p>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      <input type="checkbox" id="CheckboxBGR" onchange='onChange();' name="input_primaries" checked="true">
      <label for="CheckboxBGR">Swap RGB to BGR</label>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      Transfer:
      <input type="radio" id="RadioPQ" onchange='onChange();' name="input_transfer" checked="true">
      <label for="RadioPQ">PQ</label>

      <input type="radio" id="RadioHLG" onchange='onChange();' name="input_transfer">
      <label for="RadioHLG">HLG</label>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      Primaries:
      <input type="radio" id="RadioSRGB" onchange='onChange();' name="input_primaries">
      <label for="RadioSRGB">sRGB</label>

      <input type="radio" id="RadioP3" onchange='onChange();' name="input_primaries" checked="true">
      <label for="RadioP3">DCI P3</label>

      <input type="radio" id="RadioBT2020" onchange='onChange();' name="input_primaries" checked="true">
      <label for="RadioBT2020">ITU-R BT.2020</label>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td>
      <p><button type="button" id="ButtonSave">Save Canvas</button></p>
    </td>

  </tr>
</table>

<!-- **** CLLI, NDWL parameters **** -->
<hr>

<table style="margin-left: auto; margin-right: auto;">
  <tr>
    <td style="text-align:center;">
      <label for="CLLIMaxNits">CLLI Max Luminance (nits)</label>
      <input id="CLLIMaxNits" type="number" min="1" max="10000" value="1000"/>
    </td>

    <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

    <td style="text-align:center;">
      <label for="NDWLWhiteNits">NDWL White Luminance (nits)</label>
      <input id="NDWLWhiteNits" type="number" min="1" max="10000" value="203" onchange='onChange();'/>
    </td>
  </tr>
</table>


<!-- **** Tonemap parameters **** -->
<hr>

<table style="margin-left: auto; margin-right: auto;">
  <tr>

  <td style="text-align:center;">
    Tonemap input:<br>
    <table>
    <tr><td style="width:200px;">
      <input type="radio" name="tonemap_scalar" onchange='onChange();' id="RadioYRGB" checked="true">
      <label for="RadioYRGB">YRGB</label>
    </td></tr>
    <tr><td>
      <input type="radio" name="tonemap_scalar" onchange='onChange();' id="RadioMaxRGB">
      <label for="RadioMaxRGB">maxRGB</label>
    </td></tr>
    <tr><td>
      <input type="radio" name="tonemap_scalar" onchange='onChange();' id="RadioRpGpBp">
      <label for="RadioRpGpBp">R'G'B'</label>
    </td></tr>
    </table>
  </td>

  <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

  <td style="text-align:center;">
    Tonemap function:
    <table>
      <tr>
        <td style="width:200px;">
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioFullHDR">
          <label for="RadioFullHDR">Full HDR</label>
        </td>
        <td style="width:200px;">
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioBT2100">
          <label for="RadioBT2100">ITU-R BT.2100</label>
        </td>
      </tr>
      <tr>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioReinhard">
          <label for="RadioReinhard">Reinhard</label>
        </td>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioBT2408">
          <label for="RadioBT2408">ITU-R BT.2408</label>
        </td>
      </tr>
      <tr>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioBT2446A">
          <label for="RadioBT2446A">ITU-R BT.2446 (A)</label>
        </td>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioBT2446C">
          <label for="RadioBT2446C">ITU-R BT.2446 (C)</label>
        </td>
        <td>
        </td>
      </tr>
      <tr>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioNativePQ">
          <label for="RadioNativePQ">Native PQ</label>
        </td>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioNativeHLG">
          <label for="RadioNativeHLG">Native HLG</label>
        </td>
      </tr>
      <tr>
        <td>
          <input type="radio" name="render_mode" onchange='onToneMapChange();' id="RadioClamp" checked="true">
          <label for="RadioClamp">Clamp only</label>
        </td>
        <td>
        </td>
      </tr>
    </table>
  </td>

  <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

  <td style="text-align:center;">
    Gamut mapping:<br>
    <table>
    <tr>
      <td style="width:125px;">
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutNone">
        <label for="RadioGamutNone">None</label>
      </td>
      <td style="width:125px;">
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutClamp" checked="true">
        <label for="RadioGamutClamp">Clamp RGB</label>
      </td>
    </tr>
    <tr>
      <td>
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutScaleUV">
        <label for="RadioGamutScaleUV">Scale UV</label>
      </td>
      <td>
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutScaleRGB">
        <label for="RadioGamutScaleRGB">Scale RGB</label>
      </td>
    </tr>
    <tr>
      <td>
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutRGB_L2">
        <label for="RadioGamutRGB_L2">Min RGB L2</label>
      </td>
      <td>
        <input type="radio" name="tonemap_clamping" onchange='onChange();' id="RadioGamutYUV_L2" hidden=true>
        <label for="RadioGamutYUV_L2"  hidden=true>YUV Min L2</label>
      </td>
    </tr>
    </table>

    <input type="checkbox" onchange='onChange();' id="RadioGamutMark">
    <label for="RadioGamutMark">Mark out of gamut</label>
  </td>

  <td style="width:15px;"></td><td style="width:15px; border-left:1px solid black;"></td>

  <td style="text-align:center;">
    <p id="HLG_OOTF_Gamma"> ITU-R BT.2100<br>HLG Gamma: (unknown) </p>
    <table>
      <tr>
        <td>
          <label for="HLG_Lw_Nits">Lw (nits)</label><br>
          <input id="HLG_Lw_Nits" type="number" min="1" max="10000" value="100" onchange='onChange();'/>
        </td>
        <td>
          <input type="radio" id="RadioHLG_OOTF_f2" onchange='onChange();' name="hlg_ootf_gamma" checked="true">
          <label for="RadioHLG_OOTF_f2">Footnote 2</label>
          <br>
          <input type="radio" id="RadioHLG_OOTF_5f" onchange='onChange();' name="hlg_ootf_gamma">
          <label for="RadioHLG_OOTF_5f">Note 5f</label>
        </td>
      </tr>
    </table>
  </td>
</tr>
</table>

</div>

<div id='Viewer' style='text-align:center;'>
  <p><canvas id='Canvas' width='32' height='32'></canvas></p>
</div>

</div>
</div>

</body>
</html>
